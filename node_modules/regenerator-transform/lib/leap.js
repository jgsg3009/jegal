"use strict";

<<<<<<< HEAD
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _assert = _interopRequireDefault(require("assert"));

var _emit = require("./emit");

var _util = require("util");

var _util2 = require("./util");

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function Entry() {
  _assert["default"].ok(this instanceof Entry);
}
=======
var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

var _util = require("util");

var _util2 = require("./util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Entry() {
  _assert2.default.ok(this instanceof Entry);
} /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

function FunctionEntry(returnLoc) {
  Entry.call(this);
  (0, _util2.getTypes)().assertLiteral(returnLoc);
  this.returnLoc = returnLoc;
}

(0, _util.inherits)(FunctionEntry, Entry);
exports.FunctionEntry = FunctionEntry;

function LoopEntry(breakLoc, continueLoc, label) {
  Entry.call(this);
<<<<<<< HEAD
  var t = (0, _util2.getTypes)();
=======

  var t = (0, _util2.getTypes)();

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  t.assertLiteral(breakLoc);
  t.assertLiteral(continueLoc);

  if (label) {
    t.assertIdentifier(label);
  } else {
    label = null;
  }

  this.breakLoc = breakLoc;
  this.continueLoc = continueLoc;
  this.label = label;
}

(0, _util.inherits)(LoopEntry, Entry);
exports.LoopEntry = LoopEntry;

function SwitchEntry(breakLoc) {
  Entry.call(this);
  (0, _util2.getTypes)().assertLiteral(breakLoc);
  this.breakLoc = breakLoc;
}

(0, _util.inherits)(SwitchEntry, Entry);
exports.SwitchEntry = SwitchEntry;

function TryEntry(firstLoc, catchEntry, finallyEntry) {
  Entry.call(this);
<<<<<<< HEAD
=======

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  var t = (0, _util2.getTypes)();
  t.assertLiteral(firstLoc);

  if (catchEntry) {
<<<<<<< HEAD
    _assert["default"].ok(catchEntry instanceof CatchEntry);
=======
    _assert2.default.ok(catchEntry instanceof CatchEntry);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  } else {
    catchEntry = null;
  }

  if (finallyEntry) {
<<<<<<< HEAD
    _assert["default"].ok(finallyEntry instanceof FinallyEntry);
  } else {
    finallyEntry = null;
  } // Have to have one or the other (or both).


  _assert["default"].ok(catchEntry || finallyEntry);
=======
    _assert2.default.ok(finallyEntry instanceof FinallyEntry);
  } else {
    finallyEntry = null;
  }

  // Have to have one or the other (or both).
  _assert2.default.ok(catchEntry || finallyEntry);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

  this.firstLoc = firstLoc;
  this.catchEntry = catchEntry;
  this.finallyEntry = finallyEntry;
}

(0, _util.inherits)(TryEntry, Entry);
exports.TryEntry = TryEntry;

function CatchEntry(firstLoc, paramId) {
  Entry.call(this);
<<<<<<< HEAD
  var t = (0, _util2.getTypes)();
  t.assertLiteral(firstLoc);
  t.assertIdentifier(paramId);
=======

  var t = (0, _util2.getTypes)();

  t.assertLiteral(firstLoc);
  t.assertIdentifier(paramId);

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  this.firstLoc = firstLoc;
  this.paramId = paramId;
}

(0, _util.inherits)(CatchEntry, Entry);
exports.CatchEntry = CatchEntry;

function FinallyEntry(firstLoc, afterLoc) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(firstLoc);
  t.assertLiteral(afterLoc);
  this.firstLoc = firstLoc;
  this.afterLoc = afterLoc;
}

(0, _util.inherits)(FinallyEntry, Entry);
exports.FinallyEntry = FinallyEntry;

function LabeledEntry(breakLoc, label) {
  Entry.call(this);
<<<<<<< HEAD
  var t = (0, _util2.getTypes)();
  t.assertLiteral(breakLoc);
  t.assertIdentifier(label);
=======

  var t = (0, _util2.getTypes)();

  t.assertLiteral(breakLoc);
  t.assertIdentifier(label);

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  this.breakLoc = breakLoc;
  this.label = label;
}

(0, _util.inherits)(LabeledEntry, Entry);
exports.LabeledEntry = LabeledEntry;

function LeapManager(emitter) {
<<<<<<< HEAD
  _assert["default"].ok(this instanceof LeapManager);

  _assert["default"].ok(emitter instanceof _emit.Emitter);
=======
  _assert2.default.ok(this instanceof LeapManager);

  var Emitter = require("./emit").Emitter;
  _assert2.default.ok(emitter instanceof Emitter);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

  this.emitter = emitter;
  this.entryStack = [new FunctionEntry(emitter.finalLoc)];
}

var LMp = LeapManager.prototype;
exports.LeapManager = LeapManager;

LMp.withEntry = function (entry, callback) {
<<<<<<< HEAD
  _assert["default"].ok(entry instanceof Entry);

  this.entryStack.push(entry);

=======
  _assert2.default.ok(entry instanceof Entry);
  this.entryStack.push(entry);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  try {
    callback.call(this.emitter);
  } finally {
    var popped = this.entryStack.pop();
<<<<<<< HEAD

    _assert["default"].strictEqual(popped, entry);
=======
    _assert2.default.strictEqual(popped, entry);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  }
};

LMp._findLeapLocation = function (property, label) {
  for (var i = this.entryStack.length - 1; i >= 0; --i) {
    var entry = this.entryStack[i];
    var loc = entry[property];
<<<<<<< HEAD

=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    if (loc) {
      if (label) {
        if (entry.label && entry.label.name === label.name) {
          return loc;
        }
<<<<<<< HEAD
      } else if (entry instanceof LabeledEntry) {// Ignore LabeledEntry entries unless we are actually breaking to
=======
      } else if (entry instanceof LabeledEntry) {
        // Ignore LabeledEntry entries unless we are actually breaking to
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        // a label.
      } else {
        return loc;
      }
    }
  }

  return null;
};

LMp.getBreakLoc = function (label) {
  return this._findLeapLocation("breakLoc", label);
};

LMp.getContinueLoc = function (label) {
  return this._findLeapLocation("continueLoc", label);
};