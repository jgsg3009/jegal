'use strict';

exports.__esModule = true;
exports.default = tokenize;
<<<<<<< HEAD

var _tokenTypes = require('./tokenTypes');

var t = _interopRequireWildcard(_tokenTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var wordEnd = /[ \n\t\r\(\)\*:;!&'"\+\|~>,=$^\[\]\\]|\/(?=\*)/g;
=======
var singleQuote = 39,
    doubleQuote = 34,
    backslash = 92,
    slash = 47,
    newline = 10,
    space = 32,
    feed = 12,
    tab = 9,
    cr = 13,
    plus = 43,
    gt = 62,
    tilde = 126,
    pipe = 124,
    comma = 44,
    openBracket = 40,
    closeBracket = 41,
    openSq = 91,
    closeSq = 93,
    semicolon = 59,
    asterisk = 42,
    colon = 58,
    ampersand = 38,
    at = 64,
    atEnd = /[ \n\t\r\{\(\)'"\\;/]/g,
    wordEnd = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

function tokenize(input) {
    var tokens = [];
    var css = input.css.valueOf();
<<<<<<< HEAD
    var _css = css,
        length = _css.length;

    var offset = -1;
    var line = 1;
    var start = 0;
    var end = 0;

    var code = void 0,
        content = void 0,
        endColumn = void 0,
        endLine = void 0,
        escaped = void 0,
        escapePos = void 0,
        last = void 0,
        lines = void 0,
        next = void 0,
        nextLine = void 0,
        nextOffset = void 0,
        quote = void 0,
        tokenType = void 0;

    function unclosed(what, fix) {
        if (input.safe) {
            // fyi: this is never set to true.
            css += fix;
            next = css.length - 1;
        } else {
            throw input.error('Unclosed ' + what, line, start - offset, start);
        }
    }

    while (start < length) {
        code = css.charCodeAt(start);

        if (code === t.newline) {
            offset = start;
=======

    var code = void 0,
        next = void 0,
        quote = void 0,
        lines = void 0,
        last = void 0,
        content = void 0,
        escape = void 0,
        nextLine = void 0,
        nextOffset = void 0,
        escaped = void 0,
        escapePos = void 0;

    var length = css.length;
    var offset = -1;
    var line = 1;
    var pos = 0;

    var unclosed = function unclosed(what, end) {
        if (input.safe) {
            css += end;
            next = css.length - 1;
        } else {
            throw input.error('Unclosed ' + what, line, pos - offset, pos);
        }
    };

    while (pos < length) {
        code = css.charCodeAt(pos);

        if (code === newline) {
            offset = pos;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
            line += 1;
        }

        switch (code) {
<<<<<<< HEAD
            case t.newline:
            case t.space:
            case t.tab:
            case t.cr:
            case t.feed:
                next = start;
                do {
                    next += 1;
                    code = css.charCodeAt(next);
                    if (code === t.newline) {
                        offset = next;
                        line += 1;
                    }
                } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

                tokenType = t.space;
                endLine = line;
                endColumn = start - offset;
                end = next;
                break;

            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
                next = start;
                do {
                    next += 1;
                    code = css.charCodeAt(next);
                } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

                tokenType = t.combinator;
                endLine = line;
                endColumn = start - offset;
                end = next;
                break;

            // Consume these characters as single tokens.
            case t.asterisk:
            case t.ampersand:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
                next = start;
                tokenType = code;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
                break;

            case t.singleQuote:
            case t.doubleQuote:
                quote = code === t.singleQuote ? "'" : '"';
                next = start;
=======
            case newline:
            case space:
            case tab:
            case cr:
            case feed:
                next = pos;
                do {
                    next += 1;
                    code = css.charCodeAt(next);
                    if (code === newline) {
                        offset = next;
                        line += 1;
                    }
                } while (code === space || code === newline || code === tab || code === cr || code === feed);

                tokens.push(['space', css.slice(pos, next), line, pos - offset, pos]);
                pos = next - 1;
                break;

            case plus:
            case gt:
            case tilde:
            case pipe:
                next = pos;
                do {
                    next += 1;
                    code = css.charCodeAt(next);
                } while (code === plus || code === gt || code === tilde || code === pipe);
                tokens.push(['combinator', css.slice(pos, next), line, pos - offset, pos]);
                pos = next - 1;
                break;

            case asterisk:
                tokens.push(['*', '*', line, pos - offset, pos]);
                break;

            case ampersand:
                tokens.push(['&', '&', line, pos - offset, pos]);
                break;

            case comma:
                tokens.push([',', ',', line, pos - offset, pos]);
                break;

            case openSq:
                tokens.push(['[', '[', line, pos - offset, pos]);
                break;

            case closeSq:
                tokens.push([']', ']', line, pos - offset, pos]);
                break;

            case colon:
                tokens.push([':', ':', line, pos - offset, pos]);
                break;

            case semicolon:
                tokens.push([';', ';', line, pos - offset, pos]);
                break;

            case openBracket:
                tokens.push(['(', '(', line, pos - offset, pos]);
                break;

            case closeBracket:
                tokens.push([')', ')', line, pos - offset, pos]);
                break;

            case singleQuote:
            case doubleQuote:
                quote = code === singleQuote ? "'" : '"';
                next = pos;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
                do {
                    escaped = false;
                    next = css.indexOf(quote, next + 1);
                    if (next === -1) {
                        unclosed('quote', quote);
                    }
                    escapePos = next;
<<<<<<< HEAD
                    while (css.charCodeAt(escapePos - 1) === t.backslash) {
=======
                    while (css.charCodeAt(escapePos - 1) === backslash) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
                        escapePos -= 1;
                        escaped = !escaped;
                    }
                } while (escaped);

<<<<<<< HEAD
                tokenType = t.str;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
                break;

            case t.backslash:
                next = start;
                escaped = true;
                while (css.charCodeAt(next + 1) === t.backslash) {
                    next += 1;
                    escaped = !escaped;
                }
                code = css.charCodeAt(next + 1);
                if (escaped && code !== t.slash && code !== t.space && code !== t.newline && code !== t.tab && code !== t.cr && code !== t.feed) {
                    next += 1;
                }

                tokenType = t.word;
                endLine = line;
                endColumn = next - offset;
                end = next + 1;
                break;

            default:
                if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                    next = css.indexOf('*/', start + 2) + 1;
=======
                tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);
                pos = next;
                break;

            case at:
                atEnd.lastIndex = pos + 1;
                atEnd.test(css);
                if (atEnd.lastIndex === 0) {
                    next = css.length - 1;
                } else {
                    next = atEnd.lastIndex - 2;
                }
                tokens.push(['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);
                pos = next;
                break;

            case backslash:
                next = pos;
                escape = true;
                while (css.charCodeAt(next + 1) === backslash) {
                    next += 1;
                    escape = !escape;
                }
                code = css.charCodeAt(next + 1);
                if (escape && code !== slash && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {
                    next += 1;
                }
                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);
                pos = next;
                break;

            default:
                if (code === slash && css.charCodeAt(pos + 1) === asterisk) {
                    next = css.indexOf('*/', pos + 2) + 1;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
                    if (next === 0) {
                        unclosed('comment', '*/');
                    }

<<<<<<< HEAD
                    content = css.slice(start, next + 1);
=======
                    content = css.slice(pos, next + 1);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
                    lines = content.split('\n');
                    last = lines.length - 1;

                    if (last > 0) {
                        nextLine = line + last;
                        nextOffset = next - lines[last].length;
                    } else {
                        nextLine = line;
                        nextOffset = offset;
                    }

<<<<<<< HEAD
                    tokenType = t.comment;
                    line = nextLine;
                    endLine = nextLine;
                    endColumn = next - nextOffset;
                } else {
                    wordEnd.lastIndex = start + 1;
=======
                    tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset, pos]);

                    offset = nextOffset;
                    line = nextLine;
                    pos = next;
                } else {
                    wordEnd.lastIndex = pos + 1;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
                    wordEnd.test(css);
                    if (wordEnd.lastIndex === 0) {
                        next = css.length - 1;
                    } else {
                        next = wordEnd.lastIndex - 2;
                    }

<<<<<<< HEAD
                    tokenType = t.word;
                    endLine = line;
                    endColumn = next - offset;
                }

                end = next + 1;
                break;
        }

        // Ensure that the token structure remains consistent
        tokens.push([tokenType, // [0] Token type
        line, // [1] Starting line
        start - offset, // [2] Starting column
        endLine, // [3] Ending line
        endColumn, // [4] Ending column
        start, // [5] Start position / Source index
        end] // [6] End position
        );

        // Reset offset for the next token
        if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
        }

        start = end;
=======
                    tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);
                    pos = next;
                }

                break;
        }

        pos++;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    }

    return tokens;
}
module.exports = exports['default'];