"use strict";

<<<<<<< HEAD
var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var util = _interopRequireWildcard(require("./util"));

=======
var _util = require("./util");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var hasOwn = Object.prototype.hasOwnProperty;

// The hoist function takes a FunctionExpression or FunctionDeclaration
// and replaces any Declaration nodes in its body with assignments, then
// returns a VariableDeclaration containing just the names of the removed
// declarations.
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
<<<<<<< HEAD
var hasOwn = Object.prototype.hasOwnProperty; // The hoist function takes a FunctionExpression or FunctionDeclaration
// and replaces any Declaration nodes in its body with assignments, then
// returns a VariableDeclaration containing just the names of the removed
// declarations.
=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

exports.hoist = function (funPath) {
  var t = util.getTypes();
  t.assertFunction(funPath.node);
<<<<<<< HEAD
  var vars = {};

  function varDeclToExpr(_ref, includeIdentifiers) {
    var vdec = _ref.node,
        scope = _ref.scope;
    t.assertVariableDeclaration(vdec); // TODO assert.equal(vdec.kind, "var");

    var exprs = [];
    vdec.declarations.forEach(function (dec) {
      // Note: We duplicate 'dec.id' here to ensure that the variable declaration IDs don't
      // have the same 'loc' value, since that can make sourcemaps and retainLines behave poorly.
      vars[dec.id.name] = t.identifier(dec.id.name); // Remove the binding, to avoid "duplicate declaration" errors when it will
      // be injected again.

      scope.removeBinding(dec.id.name);
=======

  var vars = {};

  function varDeclToExpr(vdec, includeIdentifiers) {
    t.assertVariableDeclaration(vdec);
    // TODO assert.equal(vdec.kind, "var");
    var exprs = [];

    vdec.declarations.forEach(function (dec) {
      // Note: We duplicate 'dec.id' here to ensure that the variable declaration IDs don't
      // have the same 'loc' value, since that can make sourcemaps and retainLines behave poorly.
      vars[dec.id.name] = t.identifier(dec.id.name);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

      if (dec.init) {
        exprs.push(t.assignmentExpression("=", dec.id, dec.init));
      } else if (includeIdentifiers) {
        exprs.push(dec.id);
      }
    });
<<<<<<< HEAD
    if (exprs.length === 0) return null;
    if (exprs.length === 1) return exprs[0];
=======

    if (exprs.length === 0) return null;

    if (exprs.length === 1) return exprs[0];

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    return t.sequenceExpression(exprs);
  }

  funPath.get("body").traverse({
    VariableDeclaration: {
      exit: function exit(path) {
<<<<<<< HEAD
        var expr = varDeclToExpr(path, false);

=======
        var expr = varDeclToExpr(path.node, false);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        if (expr === null) {
          path.remove();
        } else {
          // We don't need to traverse this expression any further because
          // there can't be any new declarations inside an expression.
          util.replaceWithOrRemove(path, t.expressionStatement(expr));
<<<<<<< HEAD
        } // Since the original node has been either removed or replaced,
        // avoid traversing it any further.


        path.skip();
      }
    },
    ForStatement: function ForStatement(path) {
      var init = path.get("init");

      if (init.isVariableDeclaration()) {
        util.replaceWithOrRemove(init, varDeclToExpr(init, false));
      }
    },
    ForXStatement: function ForXStatement(path) {
      var left = path.get("left");

      if (left.isVariableDeclaration()) {
        util.replaceWithOrRemove(left, varDeclToExpr(left, true));
      }
    },
    FunctionDeclaration: function FunctionDeclaration(path) {
      var node = path.node;
      vars[node.id.name] = node.id;
      var assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));
=======
        }

        // Since the original node has been either removed or replaced,
        // avoid traversing it any further.
        path.skip();
      }
    },

    ForStatement: function ForStatement(path) {
      var init = path.node.init;
      if (t.isVariableDeclaration(init)) {
        util.replaceWithOrRemove(path.get("init"), varDeclToExpr(init, false));
      }
    },

    ForXStatement: function ForXStatement(path) {
      var left = path.get("left");
      if (left.isVariableDeclaration()) {
        util.replaceWithOrRemove(left, varDeclToExpr(left.node, true));
      }
    },

    FunctionDeclaration: function FunctionDeclaration(path) {
      var node = path.node;
      vars[node.id.name] = node.id;

      var assignment = t.expressionStatement(t.assignmentExpression("=", node.id, t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

      if (path.parentPath.isBlockStatement()) {
        // Insert the assignment form before the first statement in the
        // enclosing block.
<<<<<<< HEAD
        path.parentPath.unshiftContainer("body", assignment); // Remove the function declaration now that we've inserted the
        // equivalent assignment form at the beginning of the block.

=======
        path.parentPath.unshiftContainer("body", assignment);

        // Remove the function declaration now that we've inserted the
        // equivalent assignment form at the beginning of the block.
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        path.remove();
      } else {
        // If the parent node is not a block statement, then we can just
        // replace the declaration with the equivalent assignment form
        // without worrying about hoisting it.
        util.replaceWithOrRemove(path, assignment);
<<<<<<< HEAD
      } // Remove the binding, to avoid "duplicate declaration" errors when it will
      // be injected again.


      path.scope.removeBinding(node.id.name); // Don't hoist variables out of inner functions.

      path.skip();
    },
=======
      }

      // Don't hoist variables out of inner functions.
      path.skip();
    },

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    FunctionExpression: function FunctionExpression(path) {
      // Don't descend into nested function expressions.
      path.skip();
    },
<<<<<<< HEAD
=======

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    ArrowFunctionExpression: function ArrowFunctionExpression(path) {
      // Don't descend into nested function expressions.
      path.skip();
    }
  });
<<<<<<< HEAD
  var paramNames = {};
  funPath.get("params").forEach(function (paramPath) {
    var param = paramPath.node;

    if (t.isIdentifier(param)) {
      paramNames[param.name] = param;
    } else {// Variables declared by destructuring parameter patterns will be
      // harmlessly re-declared.
    }
  });
  var declarations = [];
=======

  var paramNames = {};
  funPath.get("params").forEach(function (paramPath) {
    var param = paramPath.node;
    if (t.isIdentifier(param)) {
      paramNames[param.name] = param;
    } else {
      // Variables declared by destructuring parameter patterns will be
      // harmlessly re-declared.
    }
  });

  var declarations = [];

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  Object.keys(vars).forEach(function (name) {
    if (!hasOwn.call(paramNames, name)) {
      declarations.push(t.variableDeclarator(vars[name], null));
    }
  });

  if (declarations.length === 0) {
    return null; // Be sure to handle this case!
  }

  return t.variableDeclaration("var", declarations);
};