import { traversalSearch } from 'shared/utils/traversal';

var executeApplyFn = function executeApplyFn(apply, node) {
  return typeof apply === 'function' ? apply(node) : apply;
};

var UpdatesMap = {
  name: function name(node, apply) {
    node.name = executeApplyFn(apply, node);
  },
  prefixName: function prefixName(node, apply) {
    node.prefixName = executeApplyFn(apply, node);
  },
  type: function type(node, apply) {
    node.type = executeApplyFn(apply, node);
  },
  body: function body(node, apply) {
    node.body = executeApplyFn(apply, node);
  },
  parent: function parent(node, apply) {
    node.parent = executeApplyFn(apply, node);
  }
};

var applyModifierUpdates = function applyModifierUpdates(tree, modifier) {
  var nodes = traversalSearch(tree, modifier.test);
  if (!nodes.length) return;
  var updates = Object.keys(modifier.updates || {});
  updates.filter(function (i) {
    return i !== 'subTreeUpdate';
  }).forEach(function (updateName) {
    nodes.forEach(function (node) {
      UpdatesMap[updateName](node, modifier.updates[updateName]);
    });
  });

  if (updates.includes('subTreeUpdate')) {
    modifier.updates.subTreeUpdate(nodes, tree);
  }
};

export default (function () {
  var modifiersList = [];
  return {
    addModifier: function addModifier(modifier) {
      [].concat(modifier).forEach(function (item) {
        return modifiersList.push(item);
      });
    },
    create: function create(test, updates) {
      this.addModifier({
        test: test,
        updates: updates
      });
    },
    runModifier: function runModifier(tree, modifier) {
      applyModifierUpdates(tree, modifier);
    },
    applyTo: function applyTo(tree) {
      var _this = this;

      modifiersList.forEach(function (modifier) {
        return _this.runModifier(tree, modifier);
      });
    }
  };
});