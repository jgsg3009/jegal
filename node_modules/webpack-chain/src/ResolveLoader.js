<<<<<<< HEAD
const Resolve = require('./Resolve');
const ChainedSet = require('./ChainedSet');

module.exports = class extends Resolve {
  constructor(parent) {
    super(parent);
=======
const ChainedMap = require('./ChainedMap');
const ChainedSet = require('./ChainedSet');

module.exports = class extends ChainedMap {
  constructor(parent) {
    super(parent);
    this.extensions = new ChainedSet(this);
    this.modules = new ChainedSet(this);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    this.moduleExtensions = new ChainedSet(this);
    this.packageMains = new ChainedSet(this);
  }

  toConfig() {
    return this.clean(
      Object.assign(
        {
<<<<<<< HEAD
          moduleExtensions: this.moduleExtensions.values(),
          packageMains: this.packageMains.values(),
        },
        super.toConfig()
=======
          extensions: this.extensions.values(),
          modules: this.modules.values(),
          moduleExtensions: this.moduleExtensions.values(),
          packageMains: this.packageMains.values(),
        },
        this.entries() || {}
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      )
    );
  }

  merge(obj, omit = []) {
<<<<<<< HEAD
    const omissions = ['moduleExtensions', 'packageMains'];
=======
    const omissions = [
      'extensions',
      'modules',
      'moduleExtensions',
      'packageMains',
    ];
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

    omissions.forEach(key => {
      if (!omit.includes(key) && key in obj) {
        this[key].merge(obj[key]);
      }
    });

    return super.merge(obj, [...omit, ...omissions]);
  }
};
