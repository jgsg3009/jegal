<<<<<<< HEAD
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const bfj = require('bfj');

const path = require('path');

const mkdir = require('mkdirp');

const {
  bold
} = require('chalk');

const Logger = require('./Logger');

const viewer = require('./viewer');

class BundleAnalyzerPlugin {
  constructor(opts = {}) {
    this.opts = _objectSpread({
      analyzerMode: 'server',
      analyzerHost: '127.0.0.1',
=======
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var bfj = require('bfj-node4');
var path = require('path');
var mkdir = require('mkdirp');

var _require = require('chalk'),
    bold = _require.bold;

var Logger = require('./Logger');
var viewer = require('./viewer');

var BundleAnalyzerPlugin = function () {
  function BundleAnalyzerPlugin(opts) {
    _classCallCheck(this, BundleAnalyzerPlugin);

    this.opts = Object.assign({
      analyzerMode: 'server',
      analyzerHost: '127.0.0.1',
      analyzerPort: 8888,
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      reportFilename: 'report.html',
      defaultSizes: 'parsed',
      openAnalyzer: true,
      generateStatsFile: false,
      statsFilename: 'stats.json',
      statsOptions: null,
      excludeAssets: null,
      logLevel: 'info',
      // deprecated
      startAnalyzer: true
<<<<<<< HEAD
    }, opts, {
      analyzerPort: 'analyzerPort' in opts ? opts.analyzerPort === 'auto' ? 0 : opts.analyzerPort : 8888
    });
=======
    }, opts);

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    this.server = null;
    this.logger = new Logger(this.opts.logLevel);
  }

<<<<<<< HEAD
  apply(compiler) {
    this.compiler = compiler;

    const done = (stats, callback) => {
      callback = callback || (() => {});

      const actions = [];

      if (this.opts.generateStatsFile) {
        actions.push(() => this.generateStatsFile(stats.toJson(this.opts.statsOptions)));
      } // Handling deprecated `startAnalyzer` flag


      if (this.opts.analyzerMode === 'server' && !this.opts.startAnalyzer) {
        this.opts.analyzerMode = 'disabled';
      }

      if (this.opts.analyzerMode === 'server') {
        actions.push(() => this.startAnalyzerServer(stats.toJson()));
      } else if (this.opts.analyzerMode === 'static') {
        actions.push(() => this.generateStaticReport(stats.toJson()));
      }

      if (actions.length) {
        // Making analyzer logs to be after all webpack logs in the console
        setImmediate( /*#__PURE__*/_asyncToGenerator(function* () {
          try {
            yield Promise.all(actions.map(action => action()));
            callback();
          } catch (e) {
            callback(e);
          }
        }));
      } else {
        callback();
      }
    };

    if (compiler.hooks) {
      compiler.hooks.done.tapAsync('webpack-bundle-analyzer', done);
    } else {
      compiler.plugin('done', done);
    }
  }

  generateStatsFile(stats) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const statsFilepath = path.resolve(_this.compiler.outputPath, _this.opts.statsFilename);
      mkdir.sync(path.dirname(statsFilepath));

      try {
        yield bfj.write(statsFilepath, stats, {
          space: 2,
          promises: 'ignore',
          buffers: 'ignore',
          maps: 'ignore',
          iterables: 'ignore',
          circular: 'ignore'
        });

        _this.logger.info(`${bold('Webpack Bundle Analyzer')} saved stats file to ${bold(statsFilepath)}`);
      } catch (error) {
        _this.logger.error(`${bold('Webpack Bundle Analyzer')} error saving stats file to ${bold(statsFilepath)}: ${error}`);
      }
    })();
  }

  startAnalyzerServer(stats) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      if (_this2.server) {
        (yield _this2.server).updateChartData(stats);
      } else {
        _this2.server = viewer.startServer(stats, {
          openBrowser: _this2.opts.openAnalyzer,
          host: _this2.opts.analyzerHost,
          port: _this2.opts.analyzerPort,
          bundleDir: _this2.getBundleDirFromCompiler(),
          logger: _this2.logger,
          defaultSizes: _this2.opts.defaultSizes,
          excludeAssets: _this2.opts.excludeAssets
        });
      }
    })();
  }

  generateStaticReport(stats) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      yield viewer.generateReport(stats, {
        openBrowser: _this3.opts.openAnalyzer,
        reportFilename: path.resolve(_this3.compiler.outputPath, _this3.opts.reportFilename),
        bundleDir: _this3.getBundleDirFromCompiler(),
        logger: _this3.logger,
        defaultSizes: _this3.opts.defaultSizes,
        excludeAssets: _this3.opts.excludeAssets
      });
    })();
  }

  getBundleDirFromCompiler() {
    switch (this.compiler.outputFileSystem.constructor.name) {
      case 'MemoryFileSystem':
        return null;
      // Detect AsyncMFS used by Nuxt 2.5 that replaces webpack's MFS during development
      // Related: #274

      case 'AsyncMFS':
        return null;

      default:
        return this.compiler.outputPath;
    }
  }

}
=======
  _createClass(BundleAnalyzerPlugin, [{
    key: 'apply',
    value: function apply(compiler) {
      var _this = this;

      this.compiler = compiler;

      var done = function done(stats) {
        stats = stats.toJson(_this.opts.statsOptions);

        var actions = [];

        if (_this.opts.generateStatsFile) {
          actions.push(function () {
            return _this.generateStatsFile(stats);
          });
        }

        // Handling deprecated `startAnalyzer` flag
        if (_this.opts.analyzerMode === 'server' && !_this.opts.startAnalyzer) {
          _this.opts.analyzerMode = 'disabled';
        }

        if (_this.opts.analyzerMode === 'server') {
          actions.push(function () {
            return _this.startAnalyzerServer(stats);
          });
        } else if (_this.opts.analyzerMode === 'static') {
          actions.push(function () {
            return _this.generateStaticReport(stats);
          });
        }

        if (actions.length) {
          // Making analyzer logs to be after all webpack logs in the console
          setImmediate(function () {
            actions.forEach(function (action) {
              return action();
            });
          });
        }
      };

      if (compiler.hooks) {
        compiler.hooks.done.tap('webpack-bundle-analyzer', done);
      } else {
        compiler.plugin('done', done);
      }
    }
  }, {
    key: 'generateStatsFile',
    value: function () {
      var _ref = _asyncToGenerator(function* (stats) {
        var statsFilepath = path.resolve(this.compiler.outputPath, this.opts.statsFilename);
        mkdir.sync(path.dirname(statsFilepath));

        try {
          yield bfj.write(statsFilepath, stats, {
            space: 2,
            promises: 'ignore',
            buffers: 'ignore',
            maps: 'ignore',
            iterables: 'ignore',
            circular: 'ignore'
          });

          this.logger.info(`${bold('Webpack Bundle Analyzer')} saved stats file to ${bold(statsFilepath)}`);
        } catch (error) {
          this.logger.error(`${bold('Webpack Bundle Analyzer')} error saving stats file to ${bold(statsFilepath)}: ${error}`);
        }
      });

      function generateStatsFile(_x) {
        return _ref.apply(this, arguments);
      }

      return generateStatsFile;
    }()
  }, {
    key: 'startAnalyzerServer',
    value: function () {
      var _ref2 = _asyncToGenerator(function* (stats) {
        if (this.server) {
          (yield this.server).updateChartData(stats);
        } else {
          this.server = viewer.startServer(stats, {
            openBrowser: this.opts.openAnalyzer,
            host: this.opts.analyzerHost,
            port: this.opts.analyzerPort,
            bundleDir: this.getBundleDirFromCompiler(),
            logger: this.logger,
            defaultSizes: this.opts.defaultSizes,
            excludeAssets: this.opts.excludeAssets
          });
        }
      });

      function startAnalyzerServer(_x2) {
        return _ref2.apply(this, arguments);
      }

      return startAnalyzerServer;
    }()
  }, {
    key: 'generateStaticReport',
    value: function generateStaticReport(stats) {
      viewer.generateReport(stats, {
        openBrowser: this.opts.openAnalyzer,
        reportFilename: path.resolve(this.compiler.outputPath, this.opts.reportFilename),
        bundleDir: this.getBundleDirFromCompiler(),
        logger: this.logger,
        defaultSizes: this.opts.defaultSizes,
        excludeAssets: this.opts.excludeAssets
      });
    }
  }, {
    key: 'getBundleDirFromCompiler',
    value: function getBundleDirFromCompiler() {
      return this.compiler.outputFileSystem.constructor.name === 'MemoryFileSystem' ? null : this.compiler.outputPath;
    }
  }]);

  return BundleAnalyzerPlugin;
}();
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

module.exports = BundleAnalyzerPlugin;