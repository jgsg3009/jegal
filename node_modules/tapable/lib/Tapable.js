/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const util = require("util");
const SyncBailHook = require("./SyncBailHook");

function Tapable() {
	this._pluginCompat = new SyncBailHook(["options"]);
<<<<<<< HEAD
	this._pluginCompat.tap(
		{
			name: "Tapable camelCase",
			stage: 100
		},
		options => {
			options.names.add(
				options.name.replace(/[- ]([a-z])/g, (str, ch) => ch.toUpperCase())
			);
		}
	);
	this._pluginCompat.tap(
		{
			name: "Tapable this.hooks",
			stage: 200
		},
		options => {
			let hook;
			for (const name of options.names) {
				hook = this.hooks[name];
				if (hook !== undefined) {
					break;
				}
			}
			if (hook !== undefined) {
				const tapOpt = {
					name: options.fn.name || "unnamed compat plugin",
					stage: options.stage || 0
				};
				if (options.async) hook.tapAsync(tapOpt, options.fn);
				else hook.tap(tapOpt, options.fn);
				return true;
			}
		}
	);
=======
	this._pluginCompat.tap({
		name: "Tapable camelCase",
		stage: 100
	}, options => {
		options.names.add(options.name.replace(/[- ]([a-z])/g, str => str.substr(1).toUpperCase()));
	});
	this._pluginCompat.tap({
		name: "Tapable this.hooks",
		stage: 200
	}, options => {
		let hook;
		for(const name of options.names) {
			hook = this.hooks[name];
			if(hook !== undefined) {
				break;
			}
		}
		if(hook !== undefined) {
			const tapOpt = {
				name: options.fn.name || "unnamed compat plugin",
				stage: options.stage || 0
			};
			if(options.async)
				hook.tapAsync(tapOpt, options.fn);
			else
				hook.tap(tapOpt, options.fn);
			return true;
		}
	});
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
}
module.exports = Tapable;

Tapable.addCompatLayer = function addCompatLayer(instance) {
	Tapable.call(instance);
	instance.plugin = Tapable.prototype.plugin;
	instance.apply = Tapable.prototype.apply;
};

Tapable.prototype.plugin = util.deprecate(function plugin(name, fn) {
<<<<<<< HEAD
	if (Array.isArray(name)) {
=======
	if(Array.isArray(name)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
		name.forEach(function(name) {
			this.plugin(name, fn);
		}, this);
		return;
	}
	const result = this._pluginCompat.call({
		name: name,
		fn: fn,
		names: new Set([name])
	});
<<<<<<< HEAD
	if (!result) {
		throw new Error(
			`Plugin could not be registered at '${name}'. Hook was not found.\n` +
				"BREAKING CHANGE: There need to exist a hook at 'this.hooks'. " +
				"To create a compatibility layer for this hook, hook into 'this._pluginCompat'."
		);
=======
	if(!result) {
		throw new Error(`Plugin could not be registered at '${name}'. Hook was not found.\n` +
			"BREAKING CHANGE: There need to exist a hook at 'this.hooks'. " +
			"To create a compatiblity layer for this hook, hook into 'this._pluginCompat'.");
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
	}
}, "Tapable.plugin is deprecated. Use new API on `.hooks` instead");

Tapable.prototype.apply = util.deprecate(function apply() {
<<<<<<< HEAD
	for (var i = 0; i < arguments.length; i++) {
=======
	for(var i = 0; i < arguments.length; i++) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
		arguments[i].apply(this);
	}
}, "Tapable.apply is deprecated. Call apply on the plugin directly instead");
