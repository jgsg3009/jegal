'use strict';

const mime = require('mime');
<<<<<<< HEAD

=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
const createContext = require('./lib/context');
const middleware = require('./lib/middleware');
const reporter = require('./lib/reporter');
const { setFs, toDisk } = require('./lib/fs');
const { getFilenameFromUrl, noop, ready } = require('./lib/util');

<<<<<<< HEAD
=======
require('loud-rejection/register');

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
const defaults = {
  logLevel: 'info',
  logTime: false,
  logger: null,
  mimeTypes: null,
  reporter,
  stats: {
    colors: true,
<<<<<<< HEAD
    context: process.cwd(),
  },
  watchOptions: {
    aggregateTimeout: 200,
  },
  writeToDisk: false,
=======
    context: process.cwd()
  },
  watchOptions: {
    aggregateTimeout: 200
  },
  writeToDisk: false
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
};

module.exports = function wdm(compiler, opts) {
  const options = Object.assign({}, defaults, opts);

<<<<<<< HEAD
  // defining custom MIME type
  if (options.mimeTypes) {
    const typeMap = options.mimeTypes.typeMap || options.mimeTypes;
    const force = !!options.mimeTypes.force;
    mime.define(typeMap, force);
=======
  if (options.lazy) {
    if (typeof options.filename === 'string') {
      const filename = options.filename
        .replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&') // eslint-disable-line no-useless-escape
        .replace(/\\\[[a-z]+\\\]/ig, '.+');

      options.filename = new RegExp(`^[/]{0,1}${filename}$`);
    }
  }

  // defining custom MIME type
  if (options.mimeTypes) {
    mime.define(options.mimeTypes);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  }

  const context = createContext(compiler, options);

  // start watching
  if (!options.lazy) {
<<<<<<< HEAD
    context.watching = compiler.watch(options.watchOptions, (err) => {
=======
    const watching = compiler.watch(options.watchOptions, (err) => {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      if (err) {
        context.log.error(err.stack || err);
        if (err.details) {
          context.log.error(err.details);
        }
      }
    });
<<<<<<< HEAD
  } else {
    if (typeof options.filename === 'string') {
      const filename = options.filename
        .replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&') // eslint-disable-line no-useless-escape
        .replace(/\\\[[a-z]+\\\]/gi, '.+');

      options.filename = new RegExp(`^[/]{0,1}${filename}$`);
    }

=======

    context.watching = watching;
  } else {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    context.state = true;
  }

  if (options.writeToDisk) {
    toDisk(context);
  }

  setFs(context, compiler);

  return Object.assign(middleware(context), {
    close(callback) {
<<<<<<< HEAD
      // eslint-disable-next-line no-param-reassign
=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      callback = callback || noop;

      if (context.watching) {
        context.watching.close(callback);
      } else {
        callback();
      }
    },

    context,

    fileSystem: context.fs,

<<<<<<< HEAD
    getFilenameFromUrl: getFilenameFromUrl.bind(
      this,
      context.options.publicPath,
      context.compiler
    ),

    invalidate(callback) {
      // eslint-disable-next-line no-param-reassign
      callback = callback || noop;

=======
    getFilenameFromUrl: getFilenameFromUrl.bind(this, context.options.publicPath, context.compiler),

    invalidate(callback) {
      callback = callback || noop;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      if (context.watching) {
        ready(context, callback, {});
        context.watching.invalidate();
      } else {
        callback();
      }
    },

    waitUntilValid(callback) {
<<<<<<< HEAD
      // eslint-disable-next-line no-param-reassign
      callback = callback || noop;

      ready(context, callback, {});
    },
=======
      callback = callback || noop;
      ready(context, callback, {});
    }
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  });
};
