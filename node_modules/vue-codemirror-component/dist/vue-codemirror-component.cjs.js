/*!
 * vue-codemirror-component v1.1.0
 * (c) 2018-present <ULIVZ chl814@foxmail.com>
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var CodeMirror = _interopDefault(require('codemirror'));
require('codemirror/lib/codemirror.css');
require('codemirror/mode/meta');

var findModeByName = CodeMirror.findModeByName;
var findModeByMIME = CodeMirror.findModeByMIME;
var findModeByExtension = CodeMirror.findModeByExtension;
var findModeByFileName = CodeMirror.findModeByFileName;

function normalizeModeName(mode) {
  var modeOb;
  // mode string config
  if (typeof mode == 'string') {
    modeOb = findModeByName(mode) || findModeByMIME(mode) || findModeByExtension(mode) || findModeByFileName(mode);
  } else if (typeof mode == 'object') {
    if (mode.name) {
      modeOb = findModeByName(mode.name);
    } else if (mode.ext) {
      modeOb = findModeByExtension(mode.ext);
    } else if (mode.mime) {
      modeOb = findModeByMIME(mode.mime);
    } else if (mode.filename) {
      modeOb = findModeByFileName(mode.filename);
    }
  }
  return modeOb && modeOb.mode;
}

var defaultConfig = {
  'theme': 'monokai',
  'mode': 'text/javascript'
};

var themes = ['default', '3024-day', '3024-night', 'abcdef', 'ambiance', 'base16-dark', 'base16-light', 'bespin', 'blackboard', 'cobalt', 'colorforth', 'dracula', 'duotone-dark', 'duotone-light', 'eclipse', 'elegant', 'erlang-dark', 'hopscotch', 'icecoder', 'isotope', 'lesser-dark', 'liquibyte', 'material', 'mbo', 'mdn-like', 'midnight', 'monokai', 'neat', 'neo', 'night', 'panda-syntax', 'paraiso-dark', 'paraiso-light', 'pastel-on-dark', 'railscasts', 'rubyblue', 'seti', 'solarized dark', 'solarized light', 'the-matrix', 'tomorrow-night-bright', 'tomorrow-night-eighties', 'ttcn', 'twilight', 'vibrant-ink', 'xq-dark', 'xq-light', 'yeti', 'zenburn'];

var events = ['changes', 'beforeChange', 'cursorActivity', 'keyHandled', 'inputRead', 'electricInput', 'beforeSelectionChange', 'viewportChange', 'swapDoc', 'gutterClick', 'gutterContextMenu', 'focus', 'blur', 'refresh', 'optionChange', 'scrollCursorIntoView', 'update'];

var DEFAULT_OPTIONS = {
  theme: defaultConfig.theme,
  mode: defaultConfig.mode,
  tabSize: 2
};

function createComponent(ref) {
  var loadTheme = ref.loadTheme;
  var loadMode = ref.loadMode;

  return {
    template: "<div class=\"vue-codemirror\" style=\"height: 100%; width: 100%\">\n                <textarea ref=\"editor\"></textarea>\n            </div>",

    name: 'vue-codemirror',

    props: {
      value: String,
      marker: Function,
      theme: String,
      mode: String,
      unseenLines: Array,
      options: Object
    },

    data: function data() {
      return {
        code: this.value,
        themes: themes
      };
    },

    created: function created() {
      this.loadPromises = Promise.all([this.loadMode(), this.loadTheme()]);
    },

    mounted: function mounted() {
      var this$1 = this;

      this.loadPromises.then(function () {
        this$1.initializeEditor(this$1.editorOptions);
      });
    },

    beforeDestroy: function beforeDestroy() {
      this.recycleEditor();
    },

    computed: {
      editorOptions: function editorOptions() {
        return Object.assign(DEFAULT_OPTIONS, this.options, {
          theme: this.theme || DEFAULT_OPTIONS.theme,
          mode: normalizeModeName(this.mode) || DEFAULT_OPTIONS.mode
        });
      }
    },

    watch: {
      value: function value(newVal) {
        if (newVal !== this.editor.getValue()) {
          var scrollInfo = this.editor.getScrollInfo();
          this.editor.setValue(newVal);
          this.value = newVal;
          this.editor.scrollTo(scrollInfo.left, scrollInfo.top);
        }
        this.unseenLineMarkers();
      },
      theme: function theme(theme$1) {
        var this$1 = this;

        this.editor.setOption('theme', theme$1);
        this.loadTheme().then(function () { return this$1.editor.refresh(); });
      },
      mode: function mode(mode$1) {
        var this$1 = this;

        mode$1 = normalizeModeName(mode$1);
        this.editor.setOption('mode', mode$1);
        this.loadMode().then(function () { return this$1.editor.refresh(); });
      }
    },

    methods: {

      refresh: function refresh() {
        this.editor.refresh();
      },

      undo: function undo() {
        this.editor.undo();
      },

      redo: function redo() {
        this.editor.redo();
      },

      updateEditor: function updateEditor() {
        this.recycleEditor();
        this.initializeEditor();
      },

      recycleEditor: function recycleEditor() {
        var element = this.editor.getWrapperElement();
        if (element && element.remove) {
          element.remove();
        }
      },

      unseenLineMarkers: function unseenLineMarkers() {
        var this$1 = this;

        if (this.unseenLines !== undefined && this.marker !== undefined) {
          this.unseenLines.forEach(function (line) {
            var info = this$1.editor.lineInfo(line);
            this$1.editor.setGutterMarker(line, 'breakpoints', info.gutterMarkers ? null : this$1.marker());
          });
        }
      },

      loadTheme: function loadTheme$1() {
        var ref = this.editorOptions;
        var theme = ref.theme;
        // theme config
        if (theme && theme == 'solarized light') {
          theme = 'solarized';
        }
        if (theme) {
          return loadTheme && loadTheme(theme);
        }
      },

      loadMode: function loadMode$1() {
        var ref = this.editorOptions;
        var mode = ref.mode;
        var isCustomMode = !!CodeMirror.modes[mode];

        if (!mode && !isCustomMode) {
          console.log(("Unknown mode: '" + (this.mode) + "', refer to http://codemirror.net/mode/ for more details."));
        }

        if (mode) {
          return loadMode && loadMode(mode);
        }
      },

      initializeEditor: function initializeEditor() {
        var this$1 = this;

        this.editor = CodeMirror.fromTextArea(this.$refs.editor, this.editorOptions);
        this.editor.setValue(this.code);

        this.editor.on('change', function (cm) {
          this$1.code = cm.getValue();
          var value = cm.getValue();
          this$1.$emit('input', value);
          this$1.$emit('change', value);
        });

        events.forEach(function (event) {
          this$1.editor.on(event, function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            (ref = this$1).$emit.apply(ref, [ event ].concat( args ));
            var ref;
          });
        });

        this.$emit('ready', this.editor);

        this.unseenLineMarkers();

        // prevents funky dynamic rendering
        this.$nextTick(function () {
          this$1.editor.refresh();
        }, 0);
      }
    }
  };
}

function install(Vue, options) {
  if ( options === void 0 ) options = {};

  var VueCodemirrorComponent = createComponent(options);
  Vue.component(VueCodemirrorComponent.name, VueCodemirrorComponent);
}

var modeInfo = CodeMirror.modeInfo;

exports['default'] = install;
exports.modes = modeInfo;
exports.themes = themes;
exports.createComponent = createComponent;
exports.normalizeModeName = normalizeModeName;
