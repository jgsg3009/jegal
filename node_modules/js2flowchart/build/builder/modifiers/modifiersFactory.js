function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

import { TOKEN_TYPES, TOKEN_KEYS, MODIFIED_TYPES } from 'shared/constants';

var extractNodeName = function extractNodeName(node, field) {
  var name = node.name.split(".".concat(field, "("))[0];

  if (name.includes('=')) {
    return name.split('=');
  }

  return [name];
};

var testNode = function testNode(node, field) {
  return node.name.includes(".".concat(field, "("));
};

export var DEFINED_MODIFIERS = {
  forEach: {
    test: function test(node) {
      return testNode(node, 'forEach');
    },
    updates: {
      name: function name(node) {
        return "each in  ".concat(extractNodeName(node, 'forEach')[0]);
      },
      type: TOKEN_TYPES.LOOP,
      body: function body(node) {
        return _toConsumableArray(node.body[0].body);
      }
    }
  },
  filter: {
    test: function test(node) {
      return testNode(node, 'filter');
    },
    updates: {
      name: function name(node) {
        return "in ".concat(extractNodeName(node, 'filter')[1], " to ").concat(extractNodeName(node, 'filter')[0]);
      },
      prefixName: 'filter',
      type: TOKEN_TYPES.LOOP
    }
  },
  map: {
    test: function test(node) {
      return testNode(node, 'map');
    },
    updates: {
      name: function name(node) {
        return "from ".concat(extractNodeName(node, 'map')[1], " to ").concat(extractNodeName(node, 'map')[0]);
      },
      prefixName: 'map',
      type: TOKEN_TYPES.LOOP
    }
  }
};
export var destructionModifier = function destructionModifier(test, newNameFn) {
  return {
    test: test,
    updates: {
      name: newNameFn,
      body: [],
      type: MODIFIED_TYPES.DESTRUCTED
    }
  };
};
export var arrowFunctionReturnModifier = function arrowFunctionReturnModifier() {
  return {
    test: function test(node) {
      return node.isBodyEntry && node.parent && node.parent.subType === TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION;
    },
    updates: {
      name: function name(node) {
        return 'return ' + node.name;
      },
      type: TOKEN_TYPES.RETURN
    }
  };
};
export var expressionCallbacksModifier = function expressionCallbacksModifier() {
  return {
    test: function test(node) {
      return node.pathParentType === TOKEN_TYPES.CALL_EXPRESSION;
    },
    updates: {
      subTreeUpdate: function subTreeUpdate(nodes) {
        nodes.forEach(function (node) {
          var parentBody = node.parent.body,
              index = parentBody.indexOf(node) + 1;

          for (var i = index; i < parentBody.length; i++) {
            var sibling = parentBody[i];

            if (sibling && sibling.type === TOKEN_TYPES.CALL_EXPRESSION) {
              node.parent.body = parentBody.filter(function (n) {
                return n !== node;
              });
              sibling.body = [].concat(_toConsumableArray(sibling.body || []), [node]);
              return;
            }
          }
        });
      }
    }
  };
};
export var MODIFIER_PRESETS = {
  es5ArrayIterators: [DEFINED_MODIFIERS.forEach, DEFINED_MODIFIERS.filter, DEFINED_MODIFIERS.map]
};