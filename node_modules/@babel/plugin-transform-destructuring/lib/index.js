"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

<<<<<<< HEAD
var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _core = require("@babel/core");

var _default = (0, _helperPluginUtils.declare)((api, options) => {
  api.assertVersion(7);
  const {
    loose = false,
    useBuiltIns = false
  } = options;
=======
function _helperPluginUtils() {
  const data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _core() {
  const data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)((api, options) => {
  api.assertVersion(7);
  const _options$loose = options.loose,
        loose = _options$loose === void 0 ? false : _options$loose,
        _options$useBuiltIns = options.useBuiltIns,
        useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

  if (typeof loose !== "boolean") {
    throw new Error(`.loose must be a boolean or undefined`);
  }

  const arrayOnlySpread = loose;

  function getExtendsHelper(file) {
<<<<<<< HEAD
    return useBuiltIns ? _core.types.memberExpression(_core.types.identifier("Object"), _core.types.identifier("assign")) : file.addHelper("extends");
  }

  function variableDeclarationHasPattern(node) {
    for (const declar of node.declarations) {
      if (_core.types.isPattern(declar.id)) {
=======
    return useBuiltIns ? _core().types.memberExpression(_core().types.identifier("Object"), _core().types.identifier("assign")) : file.addHelper("extends");
  }

  function variableDeclarationHasPattern(node) {
    var _arr = node.declarations;

    for (var _i = 0; _i < _arr.length; _i++) {
      const declar = _arr[_i];

      if (_core().types.isPattern(declar.id)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        return true;
      }
    }

    return false;
  }

  function hasRest(pattern) {
<<<<<<< HEAD
    for (const elem of pattern.elements) {
      if (_core.types.isRestElement(elem)) {
        return true;
      }
    }

    return false;
  }

  function hasObjectRest(pattern) {
    for (const elem of pattern.properties) {
      if (_core.types.isRestElement(elem)) {
=======
    var _arr2 = pattern.elements;

    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
      const elem = _arr2[_i2];

      if (_core().types.isRestElement(elem)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        return true;
      }
    }

    return false;
  }

<<<<<<< HEAD
  const STOP_TRAVERSAL = {};

  const arrayUnpackVisitor = (node, ancestors, state) => {
    if (!ancestors.length) {
      return;
    }

    if (_core.types.isIdentifier(node) && _core.types.isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {
      state.deopt = true;
      throw STOP_TRAVERSAL;
    }
=======
  const arrayUnpackVisitor = {
    ReferencedIdentifier(path, state) {
      if (state.bindings[path.node.name]) {
        state.deopt = true;
        path.stop();
      }
    }

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  };

  class DestructuringTransformer {
    constructor(opts) {
      this.blockHoist = opts.blockHoist;
      this.operator = opts.operator;
      this.arrays = {};
      this.nodes = opts.nodes || [];
      this.scope = opts.scope;
      this.kind = opts.kind;
      this.arrayOnlySpread = opts.arrayOnlySpread;
      this.addHelper = opts.addHelper;
    }

    buildVariableAssignment(id, init) {
      let op = this.operator;
<<<<<<< HEAD
      if (_core.types.isMemberExpression(id)) op = "=";
      let node;

      if (op) {
        node = _core.types.expressionStatement(_core.types.assignmentExpression(op, id, _core.types.cloneNode(init) || this.scope.buildUndefinedNode()));
      } else {
        node = _core.types.variableDeclaration(this.kind, [_core.types.variableDeclarator(id, _core.types.cloneNode(init))]);
=======
      if (_core().types.isMemberExpression(id)) op = "=";
      let node;

      if (op) {
        node = _core().types.expressionStatement(_core().types.assignmentExpression(op, id, _core().types.cloneNode(init)));
      } else {
        node = _core().types.variableDeclaration(this.kind, [_core().types.variableDeclarator(id, _core().types.cloneNode(init))]);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      }

      node._blockHoist = this.blockHoist;
      return node;
    }

    buildVariableDeclaration(id, init) {
<<<<<<< HEAD
      const declar = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.cloneNode(id), _core.types.cloneNode(init))]);
=======
      const declar = _core().types.variableDeclaration("var", [_core().types.variableDeclarator(_core().types.cloneNode(id), _core().types.cloneNode(init))]);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

      declar._blockHoist = this.blockHoist;
      return declar;
    }

    push(id, _init) {
<<<<<<< HEAD
      const init = _core.types.cloneNode(_init);

      if (_core.types.isObjectPattern(id)) {
        this.pushObjectPattern(id, init);
      } else if (_core.types.isArrayPattern(id)) {
        this.pushArrayPattern(id, init);
      } else if (_core.types.isAssignmentPattern(id)) {
=======
      const init = _core().types.cloneNode(_init);

      if (_core().types.isObjectPattern(id)) {
        this.pushObjectPattern(id, init);
      } else if (_core().types.isArrayPattern(id)) {
        this.pushArrayPattern(id, init);
      } else if (_core().types.isAssignmentPattern(id)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        this.pushAssignmentPattern(id, init);
      } else {
        this.nodes.push(this.buildVariableAssignment(id, init));
      }
    }

    toArray(node, count) {
<<<<<<< HEAD
      if (this.arrayOnlySpread || _core.types.isIdentifier(node) && this.arrays[node.name]) {
=======
      if (this.arrayOnlySpread || _core().types.isIdentifier(node) && this.arrays[node.name]) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        return node;
      } else {
        return this.scope.toArray(node, count);
      }
    }

    pushAssignmentPattern({
      left,
      right
    }, valueRef) {
      const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
      this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));

<<<<<<< HEAD
      const tempConditional = _core.types.conditionalExpression(_core.types.binaryExpression("===", _core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, _core.types.cloneNode(tempId));

      if (_core.types.isPattern(left)) {
=======
      const tempConditional = _core().types.conditionalExpression(_core().types.binaryExpression("===", _core().types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, _core().types.cloneNode(tempId));

      if (_core().types.isPattern(left)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        let patternId;
        let node;

        if (this.kind === "const") {
          patternId = this.scope.generateUidIdentifier(tempId.name);
          node = this.buildVariableDeclaration(patternId, tempConditional);
        } else {
          patternId = tempId;
<<<<<<< HEAD
          node = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(tempId), tempConditional));
=======
          node = _core().types.expressionStatement(_core().types.assignmentExpression("=", _core().types.cloneNode(tempId), tempConditional));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        }

        this.nodes.push(node);
        this.push(left, patternId);
      } else {
        this.nodes.push(this.buildVariableAssignment(left, tempConditional));
      }
    }

    pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
<<<<<<< HEAD
      const keys = [];
      let allLiteral = true;
=======
      let keys = [];
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

      for (let i = 0; i < pattern.properties.length; i++) {
        const prop = pattern.properties[i];
        if (i >= spreadPropIndex) break;
<<<<<<< HEAD
        if (_core.types.isRestElement(prop)) continue;
        const key = prop.key;

        if (_core.types.isIdentifier(key) && !prop.computed) {
          keys.push(_core.types.stringLiteral(key.name));
        } else if (_core.types.isTemplateLiteral(prop.key)) {
          keys.push(_core.types.cloneNode(prop.key));
        } else if (_core.types.isLiteral(key)) {
          keys.push(_core.types.stringLiteral(String(key.value)));
        } else {
          keys.push(_core.types.cloneNode(key));
          allLiteral = false;
        }
=======
        if (_core().types.isRestElement(prop)) continue;
        let key = prop.key;

        if (_core().types.isIdentifier(key) && !prop.computed) {
          key = _core().types.stringLiteral(prop.key.name);
        }

        keys.push(_core().types.cloneNode(key));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      }

      let value;

      if (keys.length === 0) {
<<<<<<< HEAD
        value = _core.types.callExpression(getExtendsHelper(this), [_core.types.objectExpression([]), _core.types.cloneNode(objRef)]);
      } else {
        let keyExpression = _core.types.arrayExpression(keys);

        if (!allLiteral) {
          keyExpression = _core.types.callExpression(_core.types.memberExpression(keyExpression, _core.types.identifier("map")), [this.addHelper("toPropertyKey")]);
        }

        value = _core.types.callExpression(this.addHelper(`objectWithoutProperties${loose ? "Loose" : ""}`), [_core.types.cloneNode(objRef), keyExpression]);
=======
        value = _core().types.callExpression(getExtendsHelper(this), [_core().types.objectExpression([]), _core().types.cloneNode(objRef)]);
      } else {
        keys = _core().types.arrayExpression(keys);
        value = _core().types.callExpression(this.addHelper("objectWithoutProperties"), [_core().types.cloneNode(objRef), keys]);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      }

      this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
    }

    pushObjectProperty(prop, propRef) {
<<<<<<< HEAD
      if (_core.types.isLiteral(prop.key)) prop.computed = true;
      const pattern = prop.value;

      const objRef = _core.types.memberExpression(_core.types.cloneNode(propRef), prop.key, prop.computed);

      if (_core.types.isPattern(pattern)) {
=======
      if (_core().types.isLiteral(prop.key)) prop.computed = true;
      const pattern = prop.value;

      const objRef = _core().types.memberExpression(_core().types.cloneNode(propRef), prop.key, prop.computed);

      if (_core().types.isPattern(pattern)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        this.push(pattern, objRef);
      } else {
        this.nodes.push(this.buildVariableAssignment(pattern, objRef));
      }
    }

    pushObjectPattern(pattern, objRef) {
      if (!pattern.properties.length) {
<<<<<<< HEAD
        this.nodes.push(_core.types.expressionStatement(_core.types.callExpression(this.addHelper("objectDestructuringEmpty"), [objRef])));
=======
        this.nodes.push(_core().types.expressionStatement(_core().types.callExpression(this.addHelper("objectDestructuringEmpty"), [objRef])));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      }

      if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
        const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
        this.nodes.push(this.buildVariableDeclaration(temp, objRef));
        objRef = temp;
      }

<<<<<<< HEAD
      if (hasObjectRest(pattern)) {
        let copiedPattern;

        for (let i = 0; i < pattern.properties.length; i++) {
          const prop = pattern.properties[i];

          if (_core.types.isRestElement(prop)) {
            break;
          }

          const key = prop.key;

          if (prop.computed && !this.scope.isPure(key)) {
            const name = this.scope.generateUidIdentifierBasedOnNode(key);
            this.nodes.push(this.buildVariableDeclaration(name, key));

            if (!copiedPattern) {
              copiedPattern = pattern = Object.assign({}, pattern, {
                properties: pattern.properties.slice()
              });
            }

            copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {
              key: name
            });
          }
        }
      }

      for (let i = 0; i < pattern.properties.length; i++) {
        const prop = pattern.properties[i];

        if (_core.types.isRestElement(prop)) {
=======
      for (let i = 0; i < pattern.properties.length; i++) {
        const prop = pattern.properties[i];

        if (_core().types.isRestElement(prop)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          this.pushObjectRest(pattern, objRef, prop, i);
        } else {
          this.pushObjectProperty(prop, objRef);
        }
      }
    }

    canUnpackArrayPattern(pattern, arr) {
<<<<<<< HEAD
      if (!_core.types.isArrayExpression(arr)) return false;
=======
      if (!_core().types.isArrayExpression(arr)) return false;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      if (pattern.elements.length > arr.elements.length) return;

      if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {
        return false;
      }

<<<<<<< HEAD
      for (const elem of pattern.elements) {
        if (!elem) return false;
        if (_core.types.isMemberExpression(elem)) return false;
      }

      for (const elem of arr.elements) {
        if (_core.types.isSpreadElement(elem)) return false;
        if (_core.types.isCallExpression(elem)) return false;
        if (_core.types.isMemberExpression(elem)) return false;
      }

      const bindings = _core.types.getBindingIdentifiers(pattern);
=======
      var _arr3 = pattern.elements;

      for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
        const elem = _arr3[_i3];
        if (!elem) return false;
        if (_core().types.isMemberExpression(elem)) return false;
      }

      var _arr4 = arr.elements;

      for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
        const elem = _arr4[_i4];
        if (_core().types.isSpreadElement(elem)) return false;
        if (_core().types.isCallExpression(elem)) return false;
        if (_core().types.isMemberExpression(elem)) return false;
      }

      const bindings = _core().types.getBindingIdentifiers(pattern);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

      const state = {
        deopt: false,
        bindings
      };
<<<<<<< HEAD

      try {
        _core.types.traverse(arr, arrayUnpackVisitor, state);
      } catch (e) {
        if (e !== STOP_TRAVERSAL) throw e;
      }

=======
      this.scope.traverse(arr, arrayUnpackVisitor, state);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      return !state.deopt;
    }

    pushUnpackedArrayPattern(pattern, arr) {
      for (let i = 0; i < pattern.elements.length; i++) {
        const elem = pattern.elements[i];

<<<<<<< HEAD
        if (_core.types.isRestElement(elem)) {
          this.push(elem.argument, _core.types.arrayExpression(arr.elements.slice(i)));
=======
        if (_core().types.isRestElement(elem)) {
          this.push(elem.argument, _core().types.arrayExpression(arr.elements.slice(i)));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        } else {
          this.push(elem, arr.elements[i]);
        }
      }
    }

    pushArrayPattern(pattern, arrayRef) {
      if (!pattern.elements) return;

      if (this.canUnpackArrayPattern(pattern, arrayRef)) {
        return this.pushUnpackedArrayPattern(pattern, arrayRef);
      }

      const count = !hasRest(pattern) && pattern.elements.length;
      const toArray = this.toArray(arrayRef, count);

<<<<<<< HEAD
      if (_core.types.isIdentifier(toArray)) {
=======
      if (_core().types.isIdentifier(toArray)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        arrayRef = toArray;
      } else {
        arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
        this.arrays[arrayRef.name] = true;
        this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
      }

      for (let i = 0; i < pattern.elements.length; i++) {
        let elem = pattern.elements[i];
        if (!elem) continue;
        let elemRef;

<<<<<<< HEAD
        if (_core.types.isRestElement(elem)) {
          elemRef = this.toArray(arrayRef);
          elemRef = _core.types.callExpression(_core.types.memberExpression(elemRef, _core.types.identifier("slice")), [_core.types.numericLiteral(i)]);
          elem = elem.argument;
        } else {
          elemRef = _core.types.memberExpression(arrayRef, _core.types.numericLiteral(i), true);
=======
        if (_core().types.isRestElement(elem)) {
          elemRef = this.toArray(arrayRef);
          elemRef = _core().types.callExpression(_core().types.memberExpression(elemRef, _core().types.identifier("slice")), [_core().types.numericLiteral(i)]);
          elem = elem.argument;
        } else {
          elemRef = _core().types.memberExpression(arrayRef, _core().types.numericLiteral(i), true);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        }

        this.push(elem, elemRef);
      }
    }

    init(pattern, ref) {
<<<<<<< HEAD
      if (!_core.types.isArrayExpression(ref) && !_core.types.isMemberExpression(ref)) {
        const memo = this.scope.maybeGenerateMemoised(ref, true);

        if (memo) {
          this.nodes.push(this.buildVariableDeclaration(memo, _core.types.cloneNode(ref)));
=======
      if (!_core().types.isArrayExpression(ref) && !_core().types.isMemberExpression(ref)) {
        const memo = this.scope.maybeGenerateMemoised(ref, true);

        if (memo) {
          this.nodes.push(this.buildVariableDeclaration(memo, _core().types.cloneNode(ref)));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          ref = memo;
        }
      }

      this.push(pattern, ref);
      return this.nodes;
    }

  }

  return {
<<<<<<< HEAD
    name: "transform-destructuring",
=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    visitor: {
      ExportNamedDeclaration(path) {
        const declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration()) return;
        if (!variableDeclarationHasPattern(declaration.node)) return;
        const specifiers = [];

<<<<<<< HEAD
        for (const name of Object.keys(path.getOuterBindingIdentifiers(path))) {
          specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));
        }

        path.replaceWith(declaration.node);
        path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));
      },

      ForXStatement(path) {
        const {
          node,
          scope
        } = path;
        const left = node.left;

        if (_core.types.isPattern(left)) {
          const temp = scope.generateUidIdentifier("ref");
          node.left = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(temp)]);
          path.ensureBlock();

          if (node.body.body.length === 0 && path.isCompletionRecord()) {
            node.body.body.unshift(_core.types.expressionStatement(scope.buildUndefinedNode()));
          }

          node.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression("=", left, temp)));
          return;
        }

        if (!_core.types.isVariableDeclaration(left)) return;
        const pattern = left.declarations[0].id;
        if (!_core.types.isPattern(pattern)) return;
        const key = scope.generateUidIdentifier("ref");
        node.left = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(key, null)]);
=======
        for (const name in path.getOuterBindingIdentifiers(path)) {
          specifiers.push(_core().types.exportSpecifier(_core().types.identifier(name), _core().types.identifier(name)));
        }

        path.replaceWith(declaration.node);
        path.insertAfter(_core().types.exportNamedDeclaration(null, specifiers));
      },

      ForXStatement(path) {
        const node = path.node,
              scope = path.scope;
        const left = node.left;

        if (_core().types.isPattern(left)) {
          const temp = scope.generateUidIdentifier("ref");
          node.left = _core().types.variableDeclaration("var", [_core().types.variableDeclarator(temp)]);
          path.ensureBlock();
          node.body.body.unshift(_core().types.variableDeclaration("var", [_core().types.variableDeclarator(left, temp)]));
          return;
        }

        if (!_core().types.isVariableDeclaration(left)) return;
        const pattern = left.declarations[0].id;
        if (!_core().types.isPattern(pattern)) return;
        const key = scope.generateUidIdentifier("ref");
        node.left = _core().types.variableDeclaration(left.kind, [_core().types.variableDeclarator(key, null)]);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        const nodes = [];
        const destructuring = new DestructuringTransformer({
          kind: left.kind,
          scope: scope,
          nodes: nodes,
          arrayOnlySpread,
          addHelper: name => this.addHelper(name)
        });
        destructuring.init(pattern, key);
        path.ensureBlock();
        const block = node.body;
        block.body = nodes.concat(block.body);
      },

      CatchClause({
        node,
        scope
      }) {
        const pattern = node.param;
<<<<<<< HEAD
        if (!_core.types.isPattern(pattern)) return;
=======
        if (!_core().types.isPattern(pattern)) return;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        const ref = scope.generateUidIdentifier("ref");
        node.param = ref;
        const nodes = [];
        const destructuring = new DestructuringTransformer({
          kind: "let",
          scope: scope,
          nodes: nodes,
          arrayOnlySpread,
          addHelper: name => this.addHelper(name)
        });
        destructuring.init(pattern, ref);
        node.body.body = nodes.concat(node.body.body);
      },

      AssignmentExpression(path) {
<<<<<<< HEAD
        const {
          node,
          scope
        } = path;
        if (!_core.types.isPattern(node.left)) return;
=======
        const node = path.node,
              scope = path.scope;
        if (!_core().types.isPattern(node.left)) return;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        const nodes = [];
        const destructuring = new DestructuringTransformer({
          operator: node.operator,
          scope: scope,
          nodes: nodes,
          arrayOnlySpread,
          addHelper: name => this.addHelper(name)
        });
        let ref;

        if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {
          ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
<<<<<<< HEAD
          nodes.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(ref, node.right)]));

          if (_core.types.isArrayExpression(node.right)) {
=======
          nodes.push(_core().types.variableDeclaration("var", [_core().types.variableDeclarator(ref, node.right)]));

          if (_core().types.isArrayExpression(node.right)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
            destructuring.arrays[ref.name] = true;
          }
        }

        destructuring.init(node.left, ref || node.right);

        if (ref) {
<<<<<<< HEAD
          if (path.parentPath.isArrowFunctionExpression()) {
            path.replaceWith(_core.types.blockStatement([]));
            nodes.push(_core.types.returnStatement(_core.types.cloneNode(ref)));
          } else {
            nodes.push(_core.types.expressionStatement(_core.types.cloneNode(ref)));
          }
        }

        path.replaceWithMultiple(nodes);
        path.scope.crawl();
      },

      VariableDeclaration(path) {
        const {
          node,
          scope,
          parent
        } = path;
        if (_core.types.isForXStatement(parent)) return;
=======
          nodes.push(_core().types.expressionStatement(_core().types.cloneNode(ref)));
        }

        path.replaceWithMultiple(nodes);
      },

      VariableDeclaration(path) {
        const node = path.node,
              scope = path.scope,
              parent = path.parent;
        if (_core().types.isForXStatement(parent)) return;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        if (!parent || !path.container) return;
        if (!variableDeclarationHasPattern(node)) return;
        const nodeKind = node.kind;
        const nodes = [];
        let declar;

        for (let i = 0; i < node.declarations.length; i++) {
          declar = node.declarations[i];
          const patternId = declar.init;
          const pattern = declar.id;
          const destructuring = new DestructuringTransformer({
            blockHoist: node._blockHoist,
            nodes: nodes,
            scope: scope,
            kind: node.kind,
            arrayOnlySpread,
            addHelper: name => this.addHelper(name)
          });

<<<<<<< HEAD
          if (_core.types.isPattern(pattern)) {
            destructuring.init(pattern, patternId);

            if (+i !== node.declarations.length - 1) {
              _core.types.inherits(nodes[nodes.length - 1], declar);
            }
          } else {
            nodes.push(_core.types.inherits(destructuring.buildVariableAssignment(declar.id, _core.types.cloneNode(declar.init)), declar));
=======
          if (_core().types.isPattern(pattern)) {
            destructuring.init(pattern, patternId);

            if (+i !== node.declarations.length - 1) {
              _core().types.inherits(nodes[nodes.length - 1], declar);
            }
          } else {
            nodes.push(_core().types.inherits(destructuring.buildVariableAssignment(declar.id, _core().types.cloneNode(declar.init)), declar));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          }
        }

        let tail = null;
        const nodesOut = [];

<<<<<<< HEAD
        for (const node of nodes) {
          if (tail !== null && _core.types.isVariableDeclaration(node)) {
=======
        for (var _i5 = 0; _i5 < nodes.length; _i5++) {
          const node = nodes[_i5];

          if (tail !== null && _core().types.isVariableDeclaration(node)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
            tail.declarations.push(...node.declarations);
          } else {
            node.kind = nodeKind;
            nodesOut.push(node);
<<<<<<< HEAD
            tail = _core.types.isVariableDeclaration(node) ? node : null;
          }
        }

        for (const nodeOut of nodesOut) {
          if (!nodeOut.declarations) continue;

          for (const declaration of nodeOut.declarations) {
            const {
              name
            } = declaration.id;
=======
            tail = _core().types.isVariableDeclaration(node) ? node : null;
          }
        }

        for (var _i6 = 0; _i6 < nodesOut.length; _i6++) {
          const nodeOut = nodesOut[_i6];
          if (!nodeOut.declarations) continue;

          for (var _iterator = nodeOut.declarations, _isArray = Array.isArray(_iterator), _i7 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i7 >= _iterator.length) break;
              _ref = _iterator[_i7++];
            } else {
              _i7 = _iterator.next();
              if (_i7.done) break;
              _ref = _i7.value;
            }

            const declaration = _ref;
            const name = declaration.id.name;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

            if (scope.bindings[name]) {
              scope.bindings[name].kind = nodeOut.kind;
            }
          }
        }

        if (nodesOut.length === 1) {
          path.replaceWith(nodesOut[0]);
        } else {
          path.replaceWithMultiple(nodesOut);
        }
      }

    }
  };
});

exports.default = _default;