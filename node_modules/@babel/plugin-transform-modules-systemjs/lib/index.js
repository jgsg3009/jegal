"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

<<<<<<< HEAD
var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperHoistVariables = _interopRequireDefault(require("@babel/helper-hoist-variables"));

var _core = require("@babel/core");

var _utils = require("babel-plugin-dynamic-import-node/utils");

var _helperModuleTransforms = require("@babel/helper-module-transforms");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const buildTemplate = (0, _core.template)(`
=======
function _helperPluginUtils() {
  const data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function _helperPluginUtils() {
    return data;
  };

  return data;
}

function _helperHoistVariables() {
  const data = _interopRequireDefault(require("@babel/helper-hoist-variables"));

  _helperHoistVariables = function _helperHoistVariables() {
    return data;
  };

  return data;
}

function _core() {
  const data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const buildTemplate = (0, _core().template)(`
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {
    "use strict";
    BEFORE_BODY;
    return {
      setters: SETTERS,
      execute: function () {
        BODY;
      }
    };
  });
`);
<<<<<<< HEAD
const buildExportAll = (0, _core.template)(`
=======
const buildExportAll = (0, _core().template)(`
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  for (var KEY in TARGET) {
    if (KEY !== "default" && KEY !== "__esModule") EXPORT_OBJ[KEY] = TARGET[KEY];
  }
`);
<<<<<<< HEAD
const MISSING_PLUGIN_WARNING = `\
WARNING: Dynamic import() transformation must be enabled using the
         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will
         no longer transform import() without using that plugin.
`;

function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget) {
  const statements = [];

  if (exportNames.length === 1) {
    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));
  } else if (!exportStarTarget) {
    const objectProperties = [];

    for (let i = 0; i < exportNames.length; i++) {
      const exportName = exportNames[i];
      const exportValue = exportValues[i];
      objectProperties.push(_core.types.objectProperty(_core.types.identifier(exportName), exportValue));
    }

    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));
  } else {
    const exportObj = path.scope.generateUid("exportObj");
    statements.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));
    statements.push(buildExportAll({
      KEY: path.scope.generateUidIdentifier("key"),
      EXPORT_OBJ: _core.types.identifier(exportObj),
      TARGET: exportStarTarget
    }));

    for (let i = 0; i < exportNames.length; i++) {
      const exportName = exportNames[i];
      const exportValue = exportValues[i];
      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));
    }

    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));
  }

  return statements;
}

var _default = (0, _helperPluginUtils.declare)((api, options) => {
  api.assertVersion(7);
  const {
    systemGlobal = "System",
    allowTopLevelThis = false
  } = options;
=======
const TYPE_IMPORT = "Import";

var _default = (0, _helperPluginUtils().declare)((api, options) => {
  api.assertVersion(7);
  const _options$systemGlobal = options.systemGlobal,
        systemGlobal = _options$systemGlobal === void 0 ? "System" : _options$systemGlobal;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  const IGNORE_REASSIGNMENT_SYMBOL = Symbol();
  const reassignmentVisitor = {
    "AssignmentExpression|UpdateExpression"(path) {
      if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
      path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
      const arg = path.get(path.isAssignmentExpression() ? "left" : "argument");
<<<<<<< HEAD

      if (arg.isObjectPattern() || arg.isArrayPattern()) {
        const exprs = [path.node];

        for (const name of Object.keys(arg.getBindingIdentifiers())) {
          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {
            return;
          }

          const exportedNames = this.exports[name];
          if (!exportedNames) return;

          for (const exportedName of exportedNames) {
            exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);
          }
        }

        path.replaceWith(_core.types.sequenceExpression(exprs));
        return;
      }

=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      if (!arg.isIdentifier()) return;
      const name = arg.node.name;
      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
      const exportedNames = this.exports[name];
      if (!exportedNames) return;
      let node = path.node;
      const isPostUpdateExpression = path.isUpdateExpression({
        prefix: false
      });

      if (isPostUpdateExpression) {
<<<<<<< HEAD
        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression("+", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));
      }

      for (const exportedName of exportedNames) {
=======
        node = _core().types.binaryExpression(node.operator[0], _core().types.unaryExpression("+", _core().types.cloneNode(node.argument)), _core().types.numericLiteral(1));
      }

      for (var _iterator = exportedNames, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        const exportedName = _ref;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        node = this.buildCall(exportedName, node).expression;
      }

      if (isPostUpdateExpression) {
<<<<<<< HEAD
        node = _core.types.sequenceExpression([node, path.node]);
=======
        node = _core().types.sequenceExpression([node, path.node]);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      }

      path.replaceWith(node);
    }

  };
  return {
<<<<<<< HEAD
    name: "transform-modules-systemjs",

    pre() {
      this.file.set("@babel/plugin-transform-modules-*", "systemjs");
    },

    visitor: {
      CallExpression(path, state) {
        if (_core.types.isImport(path.node.callee)) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
            console.warn(MISSING_PLUGIN_WARNING);
          }

          path.replaceWith(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("import")), [(0, _utils.getImportSource)(_core.types, path.node)]));
        }
      },

      MetaProperty(path, state) {
        if (path.node.meta.name === "import" && path.node.property.name === "meta") {
          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("meta")));
=======
    visitor: {
      CallExpression(path, state) {
        if (path.node.callee.type === TYPE_IMPORT) {
          path.replaceWith(_core().types.callExpression(_core().types.memberExpression(_core().types.identifier(state.contextIdent), _core().types.identifier("import")), path.node.arguments));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        }
      },

      ReferencedIdentifier(path, state) {
<<<<<<< HEAD
        if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("id")));
=======
        if (path.node.name == "__moduleName" && !path.scope.hasBinding("__moduleName")) {
          path.replaceWith(_core().types.memberExpression(_core().types.identifier(state.contextIdent), _core().types.identifier("id")));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        }
      },

      Program: {
        enter(path, state) {
          state.contextIdent = path.scope.generateUid("context");
<<<<<<< HEAD

          if (!allowTopLevelThis) {
            (0, _helperModuleTransforms.rewriteThis)(path);
          }
        },

        exit(path, state) {
          const undefinedIdent = path.scope.buildUndefinedNode();
          const exportIdent = path.scope.generateUid("export");
          const contextIdent = state.contextIdent;
          const exportMap = Object.create(null);
=======
        },

        exit(path, state) {
          const exportIdent = path.scope.generateUid("export");
          const contextIdent = state.contextIdent;
          const exportNames = Object.create(null);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          const modules = [];
          let beforeBody = [];
          const setters = [];
          const sources = [];
          const variableIds = [];
          const removedPaths = [];

          function addExportName(key, val) {
<<<<<<< HEAD
            exportMap[key] = exportMap[key] || [];
            exportMap[key].push(val);
=======
            exportNames[key] = exportNames[key] || [];
            exportNames[key].push(val);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          }

          function pushModule(source, key, specifiers) {
            let module;
            modules.forEach(function (m) {
              if (m.key === source) {
                module = m;
              }
            });

            if (!module) {
              modules.push(module = {
                key: source,
                imports: [],
                exports: []
              });
            }

            module[key] = module[key].concat(specifiers);
          }

          function buildExportCall(name, val) {
<<<<<<< HEAD
            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));
          }

          const exportNames = [];
          const exportValues = [];
          const body = path.get("body");

          for (const path of body) {
            if (path.isFunctionDeclaration()) {
              beforeBody.push(path.node);
              removedPaths.push(path);
            } else if (path.isClassDeclaration()) {
              variableIds.push(path.node.id);
              path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node))));
=======
            return _core().types.expressionStatement(_core().types.callExpression(_core().types.identifier(exportIdent), [_core().types.stringLiteral(name), val]));
          }

          const body = path.get("body");
          let canHoist = true;

          for (var _iterator2 = body, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
              if (_i2 >= _iterator2.length) break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done) break;
              _ref2 = _i2.value;
            }

            let path = _ref2;
            if (path.isExportDeclaration()) path = path.get("declaration");

            if (path.isVariableDeclaration() && path.node.kind !== "var") {
              canHoist = false;
              break;
            }
          }

          for (var _iterator3 = body, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
            var _ref3;

            if (_isArray3) {
              if (_i3 >= _iterator3.length) break;
              _ref3 = _iterator3[_i3++];
            } else {
              _i3 = _iterator3.next();
              if (_i3.done) break;
              _ref3 = _i3.value;
            }

            const path = _ref3;

            if (canHoist && path.isFunctionDeclaration()) {
              beforeBody.push(path.node);
              removedPaths.push(path);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
            } else if (path.isImportDeclaration()) {
              const source = path.node.source.value;
              pushModule(source, "imports", path.node.specifiers);

<<<<<<< HEAD
              for (const name of Object.keys(path.getBindingIdentifiers())) {
                path.scope.removeBinding(name);
                variableIds.push(_core.types.identifier(name));
=======
              for (const name in path.getBindingIdentifiers()) {
                path.scope.removeBinding(name);
                variableIds.push(_core().types.identifier(name));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
              }

              path.remove();
            } else if (path.isExportAllDeclaration()) {
              pushModule(path.node.source.value, "exports", path.node);
              path.remove();
            } else if (path.isExportDefaultDeclaration()) {
              const declar = path.get("declaration");
<<<<<<< HEAD
              const id = declar.node.id;

              if (declar.isClassDeclaration()) {
                if (id) {
                  exportNames.push("default");
                  exportValues.push(undefinedIdent);
                  variableIds.push(id);
                  addExportName(id.name, "default");
                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(id), _core.types.toExpression(declar.node))));
                } else {
                  exportNames.push("default");
                  exportValues.push(_core.types.toExpression(declar.node));
                  removedPaths.push(path);
                }
              } else if (declar.isFunctionDeclaration()) {
                if (id) {
                  beforeBody.push(declar.node);
                  exportNames.push("default");
                  exportValues.push(_core.types.cloneNode(id));
                  addExportName(id.name, "default");
                } else {
                  exportNames.push("default");
                  exportValues.push(_core.types.toExpression(declar.node));
                }

                removedPaths.push(path);
=======

              if (declar.isClassDeclaration() || declar.isFunctionDeclaration()) {
                const id = declar.node.id;
                const nodes = [];

                if (id) {
                  nodes.push(declar.node);
                  nodes.push(buildExportCall("default", _core().types.cloneNode(id)));
                  addExportName(id.name, "default");
                } else {
                  nodes.push(buildExportCall("default", _core().types.toExpression(declar.node)));
                }

                if (!canHoist || declar.isClassDeclaration()) {
                  path.replaceWithMultiple(nodes);
                } else {
                  beforeBody = beforeBody.concat(nodes);
                  removedPaths.push(path);
                }
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
              } else {
                path.replaceWith(buildExportCall("default", declar.node));
              }
            } else if (path.isExportNamedDeclaration()) {
              const declar = path.get("declaration");

              if (declar.node) {
                path.replaceWith(declar);
<<<<<<< HEAD
=======
                const nodes = [];
                let bindingIdentifiers;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

                if (path.isFunction()) {
                  const node = declar.node;
                  const name = node.id.name;
<<<<<<< HEAD
                  addExportName(name, name);
                  beforeBody.push(node);
                  exportNames.push(name);
                  exportValues.push(_core.types.cloneNode(node.id));
                  removedPaths.push(path);
                } else if (path.isClass()) {
                  const name = declar.node.id.name;
                  exportNames.push(name);
                  exportValues.push(undefinedIdent);
                  variableIds.push(declar.node.id);
                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(declar.node.id), _core.types.toExpression(declar.node))));
                  addExportName(name, name);
                } else {
                  for (const name of Object.keys(declar.getBindingIdentifiers())) {
                    addExportName(name, name);
                  }
                }
=======

                  if (canHoist) {
                    addExportName(name, name);
                    beforeBody.push(node);
                    beforeBody.push(buildExportCall(name, _core().types.cloneNode(node.id)));
                    removedPaths.push(path);
                  } else {
                    bindingIdentifiers = {
                      [name]: node.id
                    };
                  }
                } else {
                  bindingIdentifiers = declar.getBindingIdentifiers();
                }

                for (const name in bindingIdentifiers) {
                  addExportName(name, name);
                  nodes.push(buildExportCall(name, _core().types.identifier(name)));
                }

                path.insertAfter(nodes);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
              } else {
                const specifiers = path.node.specifiers;

                if (specifiers && specifiers.length) {
                  if (path.node.source) {
                    pushModule(path.node.source.value, "exports", specifiers);
                    path.remove();
                  } else {
                    const nodes = [];

<<<<<<< HEAD
                    for (const specifier of specifiers) {
                      const binding = path.scope.getBinding(specifier.local.name);

                      if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {
                        exportNames.push(specifier.exported.name);
                        exportValues.push(_core.types.cloneNode(specifier.local));
                      } else if (!binding) {
                          nodes.push(buildExportCall(specifier.exported.name, specifier.local));
                        }

=======
                    for (var _iterator6 = specifiers, _isArray6 = Array.isArray(_iterator6), _i7 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
                      var _ref6;

                      if (_isArray6) {
                        if (_i7 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i7++];
                      } else {
                        _i7 = _iterator6.next();
                        if (_i7.done) break;
                        _ref6 = _i7.value;
                      }

                      const specifier = _ref6;
                      nodes.push(buildExportCall(specifier.exported.name, specifier.local));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
                      addExportName(specifier.local.name, specifier.exported.name);
                    }

                    path.replaceWithMultiple(nodes);
                  }
<<<<<<< HEAD
                } else {
                  path.remove();
=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
                }
              }
            }
          }

          modules.forEach(function (specifiers) {
<<<<<<< HEAD
            let setterBody = [];
            const target = path.scope.generateUid(specifiers.key);

            for (let specifier of specifiers.imports) {
              if (_core.types.isImportNamespaceSpecifier(specifier)) {
                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.identifier(target))));
              } else if (_core.types.isImportDefaultSpecifier(specifier)) {
                specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier("default"));
              }

              if (_core.types.isImportSpecifier(specifier)) {
                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported))));
=======
            const setterBody = [];
            const target = path.scope.generateUid(specifiers.key);

            for (var _iterator4 = specifiers.imports, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
              var _ref4;

              if (_isArray4) {
                if (_i4 >= _iterator4.length) break;
                _ref4 = _iterator4[_i4++];
              } else {
                _i4 = _iterator4.next();
                if (_i4.done) break;
                _ref4 = _i4.value;
              }

              let specifier = _ref4;

              if (_core().types.isImportNamespaceSpecifier(specifier)) {
                setterBody.push(_core().types.expressionStatement(_core().types.assignmentExpression("=", specifier.local, _core().types.identifier(target))));
              } else if (_core().types.isImportDefaultSpecifier(specifier)) {
                specifier = _core().types.importSpecifier(specifier.local, _core().types.identifier("default"));
              }

              if (_core().types.isImportSpecifier(specifier)) {
                setterBody.push(_core().types.expressionStatement(_core().types.assignmentExpression("=", specifier.local, _core().types.memberExpression(_core().types.identifier(target), specifier.imported))));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
              }
            }

            if (specifiers.exports.length) {
<<<<<<< HEAD
              const exportNames = [];
              const exportValues = [];
              let hasExportStar = false;

              for (const node of specifiers.exports) {
                if (_core.types.isExportAllDeclaration(node)) {
                  hasExportStar = true;
                } else if (_core.types.isExportSpecifier(node)) {
                  exportNames.push(node.exported.name);
                  exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local));
                } else {}
              }

              setterBody = setterBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null));
            }

            sources.push(_core.types.stringLiteral(specifiers.key));
            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));
          });
          let moduleName = this.getModuleName();
          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
          (0, _helperHoistVariables.default)(path, (id, name, hasInit) => {
            variableIds.push(id);

            if (!hasInit) {
              exportNames.push(name);
              exportValues.push(undefinedIdent);
            }
          }, null);

          if (variableIds.length) {
            beforeBody.unshift(_core.types.variableDeclaration("var", variableIds.map(id => _core.types.variableDeclarator(id))));
          }

          if (exportNames.length) {
            beforeBody = beforeBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null));
          }

          path.traverse(reassignmentVisitor, {
            exports: exportMap,
=======
              const exportObj = path.scope.generateUid("exportObj");
              setterBody.push(_core().types.variableDeclaration("var", [_core().types.variableDeclarator(_core().types.identifier(exportObj), _core().types.objectExpression([]))]));

              for (var _iterator5 = specifiers.exports, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
                var _ref5;

                if (_isArray5) {
                  if (_i5 >= _iterator5.length) break;
                  _ref5 = _iterator5[_i5++];
                } else {
                  _i5 = _iterator5.next();
                  if (_i5.done) break;
                  _ref5 = _i5.value;
                }

                const node = _ref5;

                if (_core().types.isExportAllDeclaration(node)) {
                  setterBody.push(buildExportAll({
                    KEY: path.scope.generateUidIdentifier("key"),
                    EXPORT_OBJ: _core().types.identifier(exportObj),
                    TARGET: _core().types.identifier(target)
                  }));
                } else if (_core().types.isExportSpecifier(node)) {
                  setterBody.push(_core().types.expressionStatement(_core().types.assignmentExpression("=", _core().types.memberExpression(_core().types.identifier(exportObj), node.exported), _core().types.memberExpression(_core().types.identifier(target), node.local))));
                } else {}
              }

              setterBody.push(_core().types.expressionStatement(_core().types.callExpression(_core().types.identifier(exportIdent), [_core().types.identifier(exportObj)])));
            }

            sources.push(_core().types.stringLiteral(specifiers.key));
            setters.push(_core().types.functionExpression(null, [_core().types.identifier(target)], _core().types.blockStatement(setterBody)));
          });
          let moduleName = this.getModuleName();
          if (moduleName) moduleName = _core().types.stringLiteral(moduleName);

          if (canHoist) {
            (0, _helperHoistVariables().default)(path, id => variableIds.push(id));
          }

          if (variableIds.length) {
            beforeBody.unshift(_core().types.variableDeclaration("var", variableIds.map(id => _core().types.variableDeclarator(id))));
          }

          path.traverse(reassignmentVisitor, {
            exports: exportNames,
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
            buildCall: buildExportCall,
            scope: path.scope
          });

<<<<<<< HEAD
          for (const path of removedPaths) {
=======
          for (var _i6 = 0; _i6 < removedPaths.length; _i6++) {
            const path = removedPaths[_i6];
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
            path.remove();
          }

          path.node.body = [buildTemplate({
<<<<<<< HEAD
            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier("register")),
            BEFORE_BODY: beforeBody,
            MODULE_NAME: moduleName,
            SETTERS: _core.types.arrayExpression(setters),
            SOURCES: _core.types.arrayExpression(sources),
            BODY: path.node.body,
            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),
            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)
=======
            SYSTEM_REGISTER: _core().types.memberExpression(_core().types.identifier(systemGlobal), _core().types.identifier("register")),
            BEFORE_BODY: beforeBody,
            MODULE_NAME: moduleName,
            SETTERS: _core().types.arrayExpression(setters),
            SOURCES: _core().types.arrayExpression(sources),
            BODY: path.node.body,
            EXPORT_IDENTIFIER: _core().types.identifier(exportIdent),
            CONTEXT_IDENTIFIER: _core().types.identifier(contextIdent)
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          })];
        }

      }
    }
  };
});

exports.default = _default;