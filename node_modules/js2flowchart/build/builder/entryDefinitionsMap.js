var _DefinitionsMap;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { TOKEN_TYPES, TOKEN_KEYS } from 'shared/constants';
import { idleConverter, identifierConverter, functionConverter, isNodeContainsFunc, returnConverter, variableDeclaratorConverter, assignmentExpressionConverter, callExpressionConverter, loopConverter, continueConverter, conditionalConverter, catchConverter, tryConverter, switchStatementConverter, caseConverter, breakConverter, withStatementConverter, programConverter, throwStatementConverter, debuggerConverter, objectExpressionConverter, objectPropertyConverter } from './converters/core';
import { importDeclarationConverter, exportNamedDeclarationConverter, exportDefaultDeclarationConverter, classDeclarationConverter, objectPatternConverter, arrayPatternConverter } from './converters/Harmony';

var singleTypeFilter = function singleTypeFilter(path) {
  var statementParent = path.getStatementParent(),
      parent = path.parent || {};

  if ([TOKEN_KEYS.CONSEQUENT, TOKEN_KEYS.ALTERNATE].includes(path.key)) {
    return false;
  }

  return ['params'].includes(path.listKey) || statementParent.isReturnStatement() && path.key !== 'body' || (statementParent.isLoop() || statementParent.isConditional() || parent.type === TOKEN_TYPES.CONDITIONAL_EXPRESSION) && ['test', 'left', 'right'].includes(path.parentKey) || [TOKEN_TYPES.RETURN, TOKEN_TYPES.CALL_EXPRESSION, TOKEN_TYPES.BINARY_EXPRESSION, TOKEN_TYPES.UPDATE_EXPRESSION, TOKEN_TYPES.ASSIGNMENT_EXPRESSION, TOKEN_TYPES.LOGICAL_EXPRESSION, TOKEN_TYPES.VARIABLE_DECLARATOR, TOKEN_TYPES.MEMBER_EXPRESSION, TOKEN_TYPES.NEW_EXPRESSION, TOKEN_TYPES.FUNCTION_DECLARATION, TOKEN_TYPES.FUNCTION_EXPRESSION, TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION, TOKEN_TYPES.FUNCTION, TOKEN_TYPES.OBJECT_PROPERTY, TOKEN_TYPES.ASSIGNMENT_PATTERN, TOKEN_TYPES.REST_PROPERTY, TOKEN_TYPES.SPREAD_ELEMENT, TOKEN_TYPES.ARRAY_EXPRESSION, TOKEN_TYPES.UNARY_EXPRESSION, TOKEN_TYPES.IMPORT_DEFAULT_SPECIFIER, TOKEN_TYPES.IMPORT_SPECIFIER, TOKEN_TYPES.IMPORT_DECLARATION, TOKEN_TYPES.EXPORT_DEFAULT_DECLARATION, TOKEN_TYPES.EXPORT_NAMED_DECLARATION, TOKEN_TYPES.CLASS_DECLARATION, TOKEN_TYPES.CLASS_METHOD, TOKEN_TYPES.SWITCH_STATEMENT, TOKEN_TYPES.SWITCH_CASE].includes(parent.type) && (!parent.body || parent.body.type !== path.node.type);
};

export var DefinitionsMap = (_DefinitionsMap = {}, _defineProperty(_DefinitionsMap, TOKEN_TYPES.FUNCTION, {
  type: TOKEN_TYPES.FUNCTION,
  getName: functionConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.RETURN, {
  type: TOKEN_TYPES.RETURN,
  getName: returnConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.VARIABLE_DECLARATOR, {
  type: TOKEN_TYPES.VARIABLE_DECLARATOR,
  body: true,
  getName: variableDeclaratorConverter,
  ignore: function ignore(path) {
    var statementParent = path.getStatementParent();
    return !path.node.init || isNodeContainsFunc(path.node.init) || statementParent.isLoop();
  }
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.ASSIGNMENT_EXPRESSION, {
  type: TOKEN_TYPES.ASSIGNMENT_EXPRESSION,
  body: true,
  getName: assignmentExpressionConverter,
  ignore: function ignore(path) {
    var statementParent = path.getStatementParent();
    return statementParent.isVariableDeclaration() || path.parent.type === TOKEN_TYPES.LOGICAL_EXPRESSION || statementParent.isConditional() && path.key === TOKEN_KEYS.TEST || isNodeContainsFunc(path.node.right);
  }
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.CALL_EXPRESSION, {
  type: TOKEN_TYPES.CALL_EXPRESSION,
  body: false,
  reversed: true,
  getName: callExpressionConverter,
  ignore: function ignore(path) {
    var statementParent = path.getStatementParent(),
        parent = path.parent || {};
    if (parent.type === TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION) return false;
    return statementParent.isVariableDeclaration() || [TOKEN_TYPES.RETURN, TOKEN_TYPES.CALL_EXPRESSION, TOKEN_TYPES.NEW_EXPRESSION, TOKEN_TYPES.UNARY_EXPRESSION, TOKEN_TYPES.BINARY_EXPRESSION].includes(parent.type) || statementParent.isConditional() && parent.test && parent.test.type === TOKEN_TYPES.CALL_EXPRESSION || path.parent.type === TOKEN_TYPES.ASSIGNMENT_EXPRESSION //TODO: BUG, fix line: list = list.filter(i => i % 2)
    ;
  }
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.UPDATE_EXPRESSION, {
  type: TOKEN_TYPES.UPDATE_EXPRESSION,
  getName: idleConverter,
  ignore: function ignore(path) {
    return path.getStatementParent().isVariableDeclaration();
  }
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.NEW_EXPRESSION, {
  type: TOKEN_TYPES.NEW_EXPRESSION,
  getName: idleConverter,
  ignore: function ignore(path) {
    return path.getStatementParent().isVariableDeclaration() || path.parent.type === TOKEN_TYPES.ASSIGNMENT_EXPRESSION || path.parent.type === TOKEN_TYPES.THROW_STATEMENT;
  }
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.LOOP, {
  type: TOKEN_TYPES.LOOP,
  getName: loopConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.CONTINUE, {
  type: TOKEN_TYPES.CONTINUE,
  getName: continueConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.CONDITIONAL, {
  type: TOKEN_TYPES.CONDITIONAL,
  getName: conditionalConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.SWITCH_STATEMENT, {
  type: TOKEN_TYPES.SWITCH_STATEMENT,
  getName: switchStatementConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.SWITCH_CASE, {
  type: TOKEN_TYPES.SWITCH_CASE,
  getName: caseConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.BREAK, {
  type: TOKEN_TYPES.BREAK,
  getName: breakConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.TRY_STATEMENT, {
  type: TOKEN_TYPES.TRY_STATEMENT,
  getName: tryConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.CATCH_CLAUSE, {
  type: TOKEN_TYPES.CATCH_CLAUSE,
  getName: catchConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.WITH_STATEMENT, {
  type: TOKEN_TYPES.WITH_STATEMENT,
  //TODO: visual
  getName: withStatementConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.PROGRAM, {
  type: TOKEN_TYPES.PROGRAM,
  //TODO: visual
  getName: programConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.THROW_STATEMENT, {
  type: TOKEN_TYPES.THROW_STATEMENT,
  getName: throwStatementConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.DEBUGGER_STATEMENT, {
  type: TOKEN_TYPES.DEBUGGER_STATEMENT,
  getName: debuggerConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.BINARY_EXPRESSION, {
  type: TOKEN_TYPES.BINARY_EXPRESSION,
  getName: idleConverter,
  ignore: singleTypeFilter
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.IDENTIFIER, {
  type: TOKEN_TYPES.IDENTIFIER,
  getName: identifierConverter,
  ignore: singleTypeFilter
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.STRING_LITERAL, {
  type: TOKEN_TYPES.STRING_LITERAL,
  getName: idleConverter,
  ignore: singleTypeFilter
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.NUMERIC_LITERAL, {
  type: TOKEN_TYPES.NUMERIC_LITERAL,
  getName: idleConverter,
  ignore: singleTypeFilter
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.OBJECT_EXPRESSION, {
  type: TOKEN_TYPES.OBJECT_EXPRESSION,
  getName: objectExpressionConverter,
  ignore: function ignore(path) {
    var node = path.node;

    if (node.properties && !node.properties.length) {
      return true;
    }

    return [TOKEN_TYPES.OBJECT_PROPERTY, TOKEN_TYPES.ASSIGNMENT_EXPRESSION, TOKEN_TYPES.VARIABLE_DECLARATOR].includes(path.parent.type);
  },
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.OBJECT_PROPERTY, {
  type: TOKEN_TYPES.OBJECT_PROPERTY,
  getName: objectPropertyConverter,
  ignore: function ignore(path) {
    var parentPath = path.parentPath;
    return ['params', 'left'].includes(parentPath.parentKey);
  },
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.IMPORT_DECLARATION, {
  type: TOKEN_TYPES.IMPORT_DECLARATION,
  getName: importDeclarationConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.IMPORT_DEFAULT_SPECIFIER, {
  type: TOKEN_TYPES.IMPORT_DEFAULT_SPECIFIER,
  getName: idleConverter
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.IMPORT_SPECIFIER, {
  type: TOKEN_TYPES.IMPORT_SPECIFIER,
  getName: idleConverter
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.EXPORT_DEFAULT_DECLARATION, {
  type: TOKEN_TYPES.EXPORT_DEFAULT_DECLARATION,
  getName: exportDefaultDeclarationConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.EXPORT_NAMED_DECLARATION, {
  type: TOKEN_TYPES.EXPORT_NAMED_DECLARATION,
  getName: exportNamedDeclarationConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.CLASS_DECLARATION, {
  type: TOKEN_TYPES.CLASS_DECLARATION,
  getName: classDeclarationConverter,
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.OBJECT_PATTERN, {
  type: TOKEN_TYPES.OBJECT_PATTERN,
  getName: objectPatternConverter,
  ignore: function ignore(path) {
    return path.listKey === 'params' || [TOKEN_TYPES.VARIABLE_DECLARATOR, TOKEN_TYPES.ASSIGNMENT_PATTERN].includes(path.parent.type);
  },
  body: true
}), _defineProperty(_DefinitionsMap, TOKEN_TYPES.ARRAY_PATTERN, {
  type: TOKEN_TYPES.ARRAY_PATTERN,
  getName: arrayPatternConverter,
  ignore: function ignore(path) {
    return path.listKey === 'params' || [TOKEN_TYPES.VARIABLE_DECLARATOR, TOKEN_TYPES.ASSIGNMENT_PATTERN].includes(path.parent.type);
  },
  body: true
}), _DefinitionsMap);
export var DefinitionsList = Object.keys(DefinitionsMap).map(function (key) {
  return DefinitionsMap[key];
});