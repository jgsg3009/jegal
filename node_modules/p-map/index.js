'use strict';
<<<<<<< HEAD

const pMap = (iterable, mapper, options) => new Promise((resolve, reject) => {
	options = Object.assign({
		concurrency: Infinity
	}, options);
=======
module.exports = (iterable, mapper, opts) => new Promise((resolve, reject) => {
	opts = Object.assign({
		concurrency: Infinity
	}, opts);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

	if (typeof mapper !== 'function') {
		throw new TypeError('Mapper function is required');
	}

<<<<<<< HEAD
	const {concurrency} = options;
=======
	const concurrency = opts.concurrency;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

	if (!(typeof concurrency === 'number' && concurrency >= 1)) {
		throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
	}

	const ret = [];
	const iterator = iterable[Symbol.iterator]();
	let isRejected = false;
<<<<<<< HEAD
	let isIterableDone = false;
	let resolvingCount = 0;
	let currentIndex = 0;
=======
	let iterableDone = false;
	let resolvingCount = 0;
	let currentIdx = 0;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

	const next = () => {
		if (isRejected) {
			return;
		}

		const nextItem = iterator.next();
<<<<<<< HEAD
		const i = currentIndex;
		currentIndex++;

		if (nextItem.done) {
			isIterableDone = true;
=======
		const i = currentIdx;
		currentIdx++;

		if (nextItem.done) {
			iterableDone = true;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

			if (resolvingCount === 0) {
				resolve(ret);
			}

			return;
		}

		resolvingCount++;

		Promise.resolve(nextItem.value)
<<<<<<< HEAD
			.then(element => mapper(element, i))
			.then(
				value => {
					ret[i] = value;
					resolvingCount--;
					next();
				},
				error => {
					isRejected = true;
					reject(error);
=======
			.then(el => mapper(el, i))
			.then(
				val => {
					ret[i] = val;
					resolvingCount--;
					next();
				},
				err => {
					isRejected = true;
					reject(err);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
				}
			);
	};

	for (let i = 0; i < concurrency; i++) {
		next();

<<<<<<< HEAD
		if (isIterableDone) {
=======
		if (iterableDone) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
			break;
		}
	}
});
<<<<<<< HEAD

module.exports = pMap;
// TODO: Remove this for the next major release
module.exports.default = pMap;
=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
