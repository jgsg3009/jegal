'use strict';

<<<<<<< HEAD
const path = require('path');

const mime = require('mime');

const DevMiddlewareError = require('./DevMiddlewareError');
const {
  getFilenameFromUrl,
  handleRangeHeaders,
  handleRequest,
  ready,
} = require('./util');

// Do not add a charset to the Content-Type header of these file types
// otherwise the client will fail to render them correctly.
const NonCharsetFileTypes = /\.(wasm|usdz)$/;
=======
const mime = require('mime');
const urlJoin = require('url-join');
const DevMiddlewareError = require('./DevMiddlewareError');
const { getFilenameFromUrl, handleRangeHeaders, handleRequest, ready } = require('./util');
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

module.exports = function wrapper(context) {
  return function middleware(req, res, next) {
    // fixes #282. credit @cexoso. in certain edge situations res.locals is
    // undefined.
<<<<<<< HEAD
    // eslint-disable-next-line no-param-reassign
=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    res.locals = res.locals || {};

    function goNext() {
      if (!context.options.serverSideRender) {
        return next();
      }

<<<<<<< HEAD
      return new Promise((resolve) => {
        ready(
          context,
          () => {
            // eslint-disable-next-line no-param-reassign
            res.locals.webpackStats = context.webpackStats;
            // eslint-disable-next-line no-param-reassign
            res.locals.fs = context.fs;

            resolve(next());
          },
          req
        );
      });
    }

    const acceptedMethods = context.options.methods || ['GET', 'HEAD'];

    if (acceptedMethods.indexOf(req.method) === -1) {
      return goNext();
    }

    let filename = getFilenameFromUrl(
      context.options.publicPath,
      context.compiler,
      req.url
    );
=======
      return new Promise(((resolve) => {
        ready(context, () => {
          res.locals.webpackStats = context.webpackStats;
          resolve(next());
        }, req);
      }));
    }

    if (req.method !== 'GET') {
      return goNext();
    }

    let filename = getFilenameFromUrl(context.options.publicPath, context.compiler, req.url);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

    if (filename === false) {
      return goNext();
    }

<<<<<<< HEAD
    return new Promise((resolve) => {
      handleRequest(context, filename, processRequest, req);
      // eslint-disable-next-line consistent-return
=======
    return new Promise(((resolve) => {
      handleRequest(context, filename, processRequest, req);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      function processRequest() {
        try {
          let stat = context.fs.statSync(filename);

          if (!stat.isFile()) {
            if (stat.isDirectory()) {
              let { index } = context.options;

<<<<<<< HEAD
              // eslint-disable-next-line no-undefined
=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
              if (index === undefined || index === true) {
                index = 'index.html';
              } else if (!index) {
                throw new DevMiddlewareError('next');
              }

<<<<<<< HEAD
              filename = path.posix.join(filename, index);
              stat = context.fs.statSync(filename);

=======
              filename = urlJoin(filename, index);
              stat = context.fs.statSync(filename);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
              if (!stat.isFile()) {
                throw new DevMiddlewareError('next');
              }
            } else {
              throw new DevMiddlewareError('next');
            }
          }
        } catch (e) {
          return resolve(goNext());
        }

        // server content
        let content = context.fs.readFileSync(filename);
<<<<<<< HEAD

        content = handleRangeHeaders(content, req, res);

        let contentType = mime.getType(filename) || '';

        if (!NonCharsetFileTypes.test(filename)) {
          contentType += '; charset=UTF-8';
        }

        if (!res.getHeader || !res.getHeader('Content-Type')) {
          res.setHeader('Content-Type', contentType);
        }

        res.setHeader('Content-Length', content.length);

        const { headers } = context.options;

=======
        content = handleRangeHeaders(content, req, res);

        let contentType = mime.getType(filename);

        // do not add charset to WebAssembly files, otherwise compileStreaming will fail in the client
        if (!/\.wasm$/.test(filename)) {
          contentType += '; charset=UTF-8';
        }

        res.setHeader('Content-Type', contentType);
        res.setHeader('Content-Length', content.length);

        const { headers } = context.options;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        if (headers) {
          for (const name in headers) {
            if ({}.hasOwnProperty.call(headers, name)) {
              res.setHeader(name, context.options.headers[name]);
            }
          }
        }
<<<<<<< HEAD

        // Express automatically sets the statusCode to 200, but not all servers do (Koa).
        // eslint-disable-next-line no-param-reassign
        res.statusCode = res.statusCode || 200;

        if (res.send) {
          res.send(content);
        } else {
          res.end(content);
        }

        resolve();
      }
    });
=======
        // Express automatically sets the statusCode to 200, but not all servers do (Koa).
        res.statusCode = res.statusCode || 200;
        if (res.send) res.send(content);
        else res.end(content);
        resolve();
      }
    }));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  };
};
