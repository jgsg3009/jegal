'use strict';

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _module = require('module');

var _module2 = _interopRequireDefault(_module);

var _loaderRunner = require('loader-runner');

var _loaderRunner2 = _interopRequireDefault(_loaderRunner);

<<<<<<< HEAD
var _queue = require('neo-async/queue');
=======
var _queue = require('async/queue');
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

var _queue2 = _interopRequireDefault(_queue);

var _readBuffer = require('./readBuffer');

var _readBuffer2 = _interopRequireDefault(_readBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

<<<<<<< HEAD
const writePipe = _fs2.default.createWriteStream(null, { fd: 3 }); /* global require */
/* eslint-disable no-console */

const readPipe = _fs2.default.createReadStream(null, { fd: 4 });

writePipe.on('finish', onTerminateWrite);
readPipe.on('end', onTerminateRead);
writePipe.on('close', onTerminateWrite);
readPipe.on('close', onTerminateRead);

readPipe.on('error', onError);
writePipe.on('error', onError);

const PARALLEL_JOBS = +process.argv[2] || 20;

let terminated = false;
let nextQuestionId = 0;
const callbackMap = Object.create(null);

function onError(error) {
  console.error(error);
}

function onTerminateRead() {
  terminateRead();
}

function onTerminateWrite() {
  terminateWrite();
}

function writePipeWrite(...args) {
  if (!terminated) {
    writePipe.write(...args);
  }
}

function writePipeCork() {
  if (!terminated) {
    writePipe.cork();
  }
}

function writePipeUncork() {
  if (!terminated) {
    writePipe.uncork();
  }
}

function terminateRead() {
  terminated = true;
  readPipe.removeAllListeners();
}

function terminateWrite() {
  terminated = true;
  writePipe.removeAllListeners();
}

function terminate() {
  terminateRead();
  terminateWrite();
}
=======
var writePipe = _fs2.default.createWriteStream(null, { fd: 3 }); /* global require */
/* eslint-disable no-console */

var readPipe = _fs2.default.createReadStream(null, { fd: 4 });

writePipe.on('error', console.error.bind(console));
readPipe.on('error', console.error.bind(console));

var PARALLEL_JOBS = +process.argv[2];

var nextQuestionId = 0;
var callbackMap = Object.create(null);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

function toErrorObj(err) {
  return {
    message: err.message,
    details: err.details,
    stack: err.stack,
    hideStack: err.hideStack
  };
}

function toNativeError(obj) {
  if (!obj) return null;
<<<<<<< HEAD
  const err = new Error(obj.message);
=======
  var err = new Error(obj.message);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  err.details = obj.details;
  err.missing = obj.missing;
  return err;
}

function writeJson(data) {
<<<<<<< HEAD
  writePipeCork();
  process.nextTick(() => {
    writePipeUncork();
  });

  const lengthBuffer = Buffer.alloc(4);
  const messageBuffer = Buffer.from(JSON.stringify(data), 'utf-8');
  lengthBuffer.writeInt32BE(messageBuffer.length, 0);

  writePipeWrite(lengthBuffer);
  writePipeWrite(messageBuffer);
}

const queue = (0, _queue2.default)(({ id, data }, taskCallback) => {
=======
  writePipe.cork();
  process.nextTick(function () {
    return writePipe.uncork();
  });
  var lengthBuffer = new Buffer(4);
  var messageBuffer = new Buffer(JSON.stringify(data), 'utf-8');
  lengthBuffer.writeInt32BE(messageBuffer.length, 0);
  writePipe.write(lengthBuffer);
  writePipe.write(messageBuffer);
}

var queue = (0, _queue2.default)(function (_ref, taskCallback) {
  var id = _ref.id,
      data = _ref.data;

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  try {
    _loaderRunner2.default.runLoaders({
      loaders: data.loaders,
      resource: data.resource,
      readResource: _fs2.default.readFile.bind(_fs2.default),
      context: {
        version: 2,
<<<<<<< HEAD
        resolve: (context, request, callback) => {
=======
        resolve: function resolve(context, request, callback) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          callbackMap[nextQuestionId] = callback;
          writeJson({
            type: 'resolve',
            id,
            questionId: nextQuestionId,
            context,
            request
          });
          nextQuestionId += 1;
        },
<<<<<<< HEAD
        emitWarning: warning => {
=======
        emitWarning: function emitWarning(warning) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          writeJson({
            type: 'emitWarning',
            id,
            data: toErrorObj(warning)
          });
        },
<<<<<<< HEAD
        emitError: error => {
=======
        emitError: function emitError(error) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          writeJson({
            type: 'emitError',
            id,
            data: toErrorObj(error)
          });
        },
<<<<<<< HEAD
        exec: (code, filename) => {
          const module = new _module2.default(filename, undefined);
=======
        exec: function exec(code, filename) {
          var module = new _module2.default(filename, undefined);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          module.paths = _module2.default._nodeModulePaths(undefined.context); // eslint-disable-line no-underscore-dangle
          module.filename = filename;
          module._compile(code, filename); // eslint-disable-line no-underscore-dangle
          return module.exports;
        },
        options: {
          context: data.optionsContext
        },
        webpack: true,
        'thread-loader': true,
        sourceMap: data.sourceMap,
        target: data.target,
        minimize: data.minimize,
        resourceQuery: data.resourceQuery
      }
<<<<<<< HEAD
    }, (err, lrResult) => {
      const {
        result,
        cacheable,
        fileDependencies,
        contextDependencies
      } = lrResult;
      const buffersToSend = [];
      const convertedResult = Array.isArray(result) && result.map(item => {
        const isBuffer = Buffer.isBuffer(item);
=======
    }, function (err, lrResult) {
      var result = lrResult.result,
          cacheable = lrResult.cacheable,
          fileDependencies = lrResult.fileDependencies,
          contextDependencies = lrResult.contextDependencies;

      var buffersToSend = [];
      var convertedResult = Array.isArray(result) && result.map(function (item) {
        var isBuffer = Buffer.isBuffer(item);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        if (isBuffer) {
          buffersToSend.push(item);
          return {
            buffer: true
          };
        }
        if (typeof item === 'string') {
<<<<<<< HEAD
          const stringBuffer = Buffer.from(item, 'utf-8');
=======
          var stringBuffer = new Buffer(item, 'utf-8');
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          buffersToSend.push(stringBuffer);
          return {
            buffer: true,
            string: true
          };
        }
        return {
          data: item
        };
      });
      writeJson({
        type: 'job',
        id,
        error: err && toErrorObj(err),
        result: {
          result: convertedResult,
          cacheable,
          fileDependencies,
          contextDependencies
        },
<<<<<<< HEAD
        data: buffersToSend.map(buffer => buffer.length)
      });
      buffersToSend.forEach(buffer => {
        writePipeWrite(buffer);
=======
        data: buffersToSend.map(function (buffer) {
          return buffer.length;
        })
      });
      buffersToSend.forEach(function (buffer) {
        writePipe.write(buffer);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      });
      setImmediate(taskCallback);
    });
  } catch (e) {
    writeJson({
      type: 'job',
      id,
      error: toErrorObj(e)
    });
    taskCallback();
  }
}, PARALLEL_JOBS);

<<<<<<< HEAD
function dispose() {
  terminate();

  queue.kill();
  process.exit(0);
}

function onMessage(message) {
  try {
    const { type, id } = message;
=======
function onMessage(message) {
  try {
    var type = message.type,
        id = message.id;

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    switch (type) {
      case 'job':
        {
          queue.push(message);
          break;
        }
      case 'result':
        {
<<<<<<< HEAD
          const { error, result } = message;
          const callback = callbackMap[id];
          if (callback) {
            const nativeError = toNativeError(error);
=======
          var error = message.error,
              result = message.result;

          var callback = callbackMap[id];
          if (callback) {
            var nativeError = toNativeError(error);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
            callback(nativeError, result);
          } else {
            console.error(`Worker got unexpected result id ${id}`);
          }
          delete callbackMap[id];
          break;
        }
      case 'warmup':
        {
<<<<<<< HEAD
          const { requires } = message;
          // load modules into process
          requires.forEach(r => require(r)); // eslint-disable-line import/no-dynamic-require, global-require
=======
          var requires = message.requires;
          // load modules into process

          requires.forEach(function (r) {
            return require(r);
          }); // eslint-disable-line import/no-dynamic-require, global-require
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
          break;
        }
      default:
        {
          console.error(`Worker got unexpected job type ${type}`);
          break;
        }
    }
  } catch (e) {
    console.error(`Error in worker ${e}`);
  }
}

function readNextMessage() {
<<<<<<< HEAD
  (0, _readBuffer2.default)(readPipe, 4, (lengthReadError, lengthBuffer) => {
=======
  (0, _readBuffer2.default)(readPipe, 4, function (lengthReadError, lengthBuffer) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    if (lengthReadError) {
      console.error(`Failed to communicate with main process (read length) ${lengthReadError}`);
      return;
    }
<<<<<<< HEAD

    const length = lengthBuffer.length && lengthBuffer.readInt32BE(0);

    if (length === 0) {
      // worker should dispose and exit
      dispose();
      return;
    }
    (0, _readBuffer2.default)(readPipe, length, (messageError, messageBuffer) => {
      if (terminated) {
        return;
      }

=======
    var length = lengthBuffer.readInt32BE(0);
    if (length === 0) {
      // worker should exit
      process.exit(0);
      return;
    }
    (0, _readBuffer2.default)(readPipe, length, function (messageError, messageBuffer) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      if (messageError) {
        console.error(`Failed to communicate with main process (read message) ${messageError}`);
        return;
      }
<<<<<<< HEAD
      const messageString = messageBuffer.toString('utf-8');
      const message = JSON.parse(messageString);

      onMessage(message);
      setImmediate(() => readNextMessage());
=======
      var messageString = messageBuffer.toString('utf-8');
      var message = JSON.parse(messageString);
      onMessage(message);
      setImmediate(function () {
        return readNextMessage();
      });
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    });
  });
}

// start reading messages from main process
readNextMessage();