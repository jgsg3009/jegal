"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = populatePlaceholders;

<<<<<<< HEAD
var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function populatePlaceholders(metadata, replacements) {
  const ast = t.cloneNode(metadata.ast);
=======
function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function t() {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function populatePlaceholders(metadata, replacements) {
  const ast = t().cloneNode(metadata.ast);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

  if (replacements) {
    metadata.placeholders.forEach(placeholder => {
      if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
        const placeholderName = placeholder.name;
        throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
      }
    });
    Object.keys(replacements).forEach(key => {
      if (!metadata.placeholderNames.has(key)) {
        throw new Error(`Unknown substitution "${key}" given`);
      }
    });
  }

  metadata.placeholders.slice().reverse().forEach(placeholder => {
    try {
      applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
    } catch (e) {
      e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
      throw e;
    }
  });
  return ast;
}

function applyReplacement(placeholder, ast, replacement) {
  if (placeholder.isDuplicate) {
    if (Array.isArray(replacement)) {
<<<<<<< HEAD
      replacement = replacement.map(node => t.cloneNode(node));
    } else if (typeof replacement === "object") {
      replacement = t.cloneNode(replacement);
    }
  }

  const {
    parent,
    key,
    index
  } = placeholder.resolve(ast);

  if (placeholder.type === "string") {
    if (typeof replacement === "string") {
      replacement = t.stringLiteral(replacement);
    }

    if (!replacement || !t.isStringLiteral(replacement)) {
=======
      replacement = replacement.map(node => t().cloneNode(node));
    } else if (typeof replacement === "object") {
      replacement = t().cloneNode(replacement);
    }
  }

  const _placeholder$resolve = placeholder.resolve(ast),
        parent = _placeholder$resolve.parent,
        key = _placeholder$resolve.key,
        index = _placeholder$resolve.index;

  if (placeholder.type === "string") {
    if (typeof replacement === "string") {
      replacement = t().stringLiteral(replacement);
    }

    if (!replacement || !t().isStringLiteral(replacement)) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      throw new Error("Expected string substitution");
    }
  } else if (placeholder.type === "statement") {
    if (index === undefined) {
      if (!replacement) {
<<<<<<< HEAD
        replacement = t.emptyStatement();
      } else if (Array.isArray(replacement)) {
        replacement = t.blockStatement(replacement);
      } else if (typeof replacement === "string") {
        replacement = t.expressionStatement(t.identifier(replacement));
      } else if (!t.isStatement(replacement)) {
        replacement = t.expressionStatement(replacement);
=======
        replacement = t().emptyStatement();
      } else if (Array.isArray(replacement)) {
        replacement = t().blockStatement(replacement);
      } else if (typeof replacement === "string") {
        replacement = t().expressionStatement(t().identifier(replacement));
      } else if (!t().isStatement(replacement)) {
        replacement = t().expressionStatement(replacement);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      }
    } else {
      if (replacement && !Array.isArray(replacement)) {
        if (typeof replacement === "string") {
<<<<<<< HEAD
          replacement = t.identifier(replacement);
        }

        if (!t.isStatement(replacement)) {
          replacement = t.expressionStatement(replacement);
=======
          replacement = t().identifier(replacement);
        }

        if (!t().isStatement(replacement)) {
          replacement = t().expressionStatement(replacement);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        }
      }
    }
  } else if (placeholder.type === "param") {
    if (typeof replacement === "string") {
<<<<<<< HEAD
      replacement = t.identifier(replacement);
=======
      replacement = t().identifier(replacement);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    }

    if (index === undefined) throw new Error("Assertion failure.");
  } else {
    if (typeof replacement === "string") {
<<<<<<< HEAD
      replacement = t.identifier(replacement);
=======
      replacement = t().identifier(replacement);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    }

    if (Array.isArray(replacement)) {
      throw new Error("Cannot replace single expression with an array.");
    }
  }

  if (index === undefined) {
<<<<<<< HEAD
    t.validate(parent, key, replacement);
=======
    t().validate(parent, key, replacement);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    parent[key] = replacement;
  } else {
    const items = parent[key].slice();

    if (placeholder.type === "statement" || placeholder.type === "param") {
      if (replacement == null) {
        items.splice(index, 1);
      } else if (Array.isArray(replacement)) {
        items.splice(index, 1, ...replacement);
      } else {
        items[index] = replacement;
      }
    } else {
      items[index] = replacement;
    }

<<<<<<< HEAD
    t.validate(parent, key, items);
=======
    t().validate(parent, key, items);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    parent[key] = items;
  }
}