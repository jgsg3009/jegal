<<<<<<< HEAD
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const path = require('path');

const fs = require('fs');

const http = require('http');

const WebSocket = require('ws');

const _ = require('lodash');

const express = require('express');

const ejs = require('ejs');

const opener = require('opener');

const mkdir = require('mkdirp');

const {
  bold
} = require('chalk');

const utils = require('./utils');

const Logger = require('./Logger');

const analyzer = require('./analyzer');

const projectRoot = path.resolve(__dirname, '..');
const assetsRoot = path.join(projectRoot, 'public');
module.exports = {
  startServer,
  generateReport,
  // deprecated
  start: startServer
};
const title = `${process.env.npm_package_name || 'Webpack Bundle Analyzer'} [${utils.getCurrentTime()}]`;

function startServer(_x, _x2) {
  return _startServer.apply(this, arguments);
}

function _startServer() {
  _startServer = _asyncToGenerator(function* (bundleStats, opts) {
    const {
      port = 8888,
      host = '127.0.0.1',
      openBrowser = true,
      bundleDir = null,
      logger = new Logger(),
      defaultSizes = 'parsed',
      excludeAssets = null
    } = opts || {};
    const analyzerOpts = {
      logger,
      excludeAssets
    };
    let chartData = getChartData(analyzerOpts, bundleStats, bundleDir);
    if (!chartData) return;
    const app = express(); // Explicitly using our `ejs` dependency to render templates
    // Fixes #17

=======
'use strict';

var startServer = function () {
  var _ref = _asyncToGenerator(function* (bundleStats, opts) {
    var _ref2 = opts || {},
        _ref2$port = _ref2.port,
        port = _ref2$port === undefined ? 8888 : _ref2$port,
        _ref2$host = _ref2.host,
        host = _ref2$host === undefined ? '127.0.0.1' : _ref2$host,
        _ref2$openBrowser = _ref2.openBrowser,
        openBrowser = _ref2$openBrowser === undefined ? true : _ref2$openBrowser,
        _ref2$bundleDir = _ref2.bundleDir,
        bundleDir = _ref2$bundleDir === undefined ? null : _ref2$bundleDir,
        _ref2$logger = _ref2.logger,
        logger = _ref2$logger === undefined ? new Logger() : _ref2$logger,
        _ref2$defaultSizes = _ref2.defaultSizes,
        defaultSizes = _ref2$defaultSizes === undefined ? 'parsed' : _ref2$defaultSizes,
        _ref2$excludeAssets = _ref2.excludeAssets,
        excludeAssets = _ref2$excludeAssets === undefined ? null : _ref2$excludeAssets;

    var analyzerOpts = { logger, excludeAssets };

    var chartData = getChartData(analyzerOpts, bundleStats, bundleDir);

    if (!chartData) return;

    var app = express();

    // Explicitly using our `ejs` dependency to render templates
    // Fixes #17
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    app.engine('ejs', require('ejs').renderFile);
    app.set('view engine', 'ejs');
    app.set('views', `${projectRoot}/views`);
    app.use(express.static(`${projectRoot}/public`));
<<<<<<< HEAD
    app.use('/', (req, res) => {
      res.render('viewer', {
        mode: 'server',
        title,

        get chartData() {
          return chartData;
        },

        defaultSizes,
        enableWebSocket: true,
        // Helpers
        escapeJson
      });
    });
    const server = http.createServer(app);
    yield new Promise(resolve => {
      server.listen(port, host, () => {
        resolve();
        const url = `http://${host}:${server.address().port}`;
=======

    app.use('/', function (req, res) {
      res.render('viewer', {
        mode: 'server',
        get chartData() {
          return JSON.stringify(chartData);
        },
        defaultSizes: JSON.stringify(defaultSizes)
      });
    });

    var server = http.createServer(app);

    yield new Promise(function (resolve) {
      server.listen(port, host, function () {
        resolve();

        var url = `http://${host}:${server.address().port}`;

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        logger.info(`${bold('Webpack Bundle Analyzer')} is started at ${bold(url)}\n` + `Use ${bold('Ctrl+C')} to close it`);

        if (openBrowser) {
          opener(url);
        }
      });
    });
<<<<<<< HEAD
    const wss = new WebSocket.Server({
      server
    });
    wss.on('connection', ws => {
      ws.on('error', err => {
        // Ignore network errors like `ECONNRESET`, `EPIPE`, etc.
        if (err.errno) return;
        logger.info(err.message);
      });
    });
=======

    var wss = new WebSocket.Server({ server });

    wss.on('connection', function (ws) {
      ws.on('error', function (err) {
        // Ignore network errors like `ECONNRESET`, `EPIPE`, etc.
        if (err.errno) return;

        logger.info(err.message);
      });
    });

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    return {
      ws: wss,
      http: server,
      updateChartData
    };

    function updateChartData(bundleStats) {
<<<<<<< HEAD
      const newChartData = getChartData(analyzerOpts, bundleStats, bundleDir);
      if (!newChartData) return;
      chartData = newChartData;
      wss.clients.forEach(client => {
=======
      var newChartData = getChartData(analyzerOpts, bundleStats, bundleDir);

      if (!newChartData) return;

      chartData = newChartData;

      wss.clients.forEach(function (client) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({
            event: 'chartDataUpdated',
            data: newChartData
          }));
        }
      });
    }
  });
<<<<<<< HEAD
  return _startServer.apply(this, arguments);
}

function generateReport(_x3, _x4) {
  return _generateReport.apply(this, arguments);
}

function _generateReport() {
  _generateReport = _asyncToGenerator(function* (bundleStats, opts) {
    const {
      openBrowser = true,
      reportFilename = 'report.html',
      bundleDir = null,
      logger = new Logger(),
      defaultSizes = 'parsed',
      excludeAssets = null
    } = opts || {};
    const chartData = getChartData({
      logger,
      excludeAssets
    }, bundleStats, bundleDir);
    if (!chartData) return;
    yield new Promise((resolve, reject) => {
      ejs.renderFile(`${projectRoot}/views/viewer.ejs`, {
        mode: 'static',
        title,
        chartData,
        defaultSizes,
        enableWebSocket: false,
        // Helpers
        assetContent: getAssetContent,
        escapeJson
      }, (err, reportHtml) => {
        try {
          if (err) {
            logger.error(err);
            reject(err);
            return;
          }

          const reportFilepath = path.resolve(bundleDir || process.cwd(), reportFilename);
          mkdir.sync(path.dirname(reportFilepath));
          fs.writeFileSync(reportFilepath, reportHtml);
          logger.info(`${bold('Webpack Bundle Analyzer')} saved report to ${bold(reportFilepath)}`);

          if (openBrowser) {
            opener(`file://${reportFilepath}`);
          }

          resolve();
        } catch (e) {
          reject(e);
        }
      });
    });
  });
  return _generateReport.apply(this, arguments);
}

function getAssetContent(filename) {
  const assetPath = path.join(assetsRoot, filename);

  if (!assetPath.startsWith(assetsRoot)) {
    throw new Error(`"${filename}" is outside of the assets root`);
  }

  return fs.readFileSync(assetPath, 'utf8');
}
/**
 * Escapes `<` characters in JSON to safely use it in `<script>` tag.
 */


function escapeJson(json) {
  return JSON.stringify(json).replace(/</gu, '\\u003c');
}

function getChartData(analyzerOpts, ...args) {
  let chartData;
  const {
    logger
  } = analyzerOpts;

  try {
    chartData = analyzer.getViewerData(...args, analyzerOpts);
=======

  return function startServer(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var path = require('path');
var fs = require('fs');
var http = require('http');

var WebSocket = require('ws');
var _ = require('lodash');
var express = require('express');
var ejs = require('ejs');
var opener = require('opener');
var mkdir = require('mkdirp');

var _require = require('chalk'),
    bold = _require.bold;

var Logger = require('./Logger');
var analyzer = require('./analyzer');

var projectRoot = path.resolve(__dirname, '..');

module.exports = {
  startServer,
  generateReport,
  // deprecated
  start: startServer
};

function generateReport(bundleStats, opts) {
  var _ref3 = opts || {},
      _ref3$openBrowser = _ref3.openBrowser,
      openBrowser = _ref3$openBrowser === undefined ? true : _ref3$openBrowser,
      _ref3$reportFilename = _ref3.reportFilename,
      reportFilename = _ref3$reportFilename === undefined ? 'report.html' : _ref3$reportFilename,
      _ref3$bundleDir = _ref3.bundleDir,
      bundleDir = _ref3$bundleDir === undefined ? null : _ref3$bundleDir,
      _ref3$logger = _ref3.logger,
      logger = _ref3$logger === undefined ? new Logger() : _ref3$logger,
      _ref3$defaultSizes = _ref3.defaultSizes,
      defaultSizes = _ref3$defaultSizes === undefined ? 'parsed' : _ref3$defaultSizes,
      _ref3$excludeAssets = _ref3.excludeAssets,
      excludeAssets = _ref3$excludeAssets === undefined ? null : _ref3$excludeAssets;

  var chartData = getChartData({ logger, excludeAssets }, bundleStats, bundleDir);

  if (!chartData) return;

  ejs.renderFile(`${projectRoot}/views/viewer.ejs`, {
    mode: 'static',
    chartData: JSON.stringify(chartData),
    assetContent: getAssetContent,
    defaultSizes: JSON.stringify(defaultSizes)
  }, function (err, reportHtml) {
    if (err) return logger.error(err);

    var reportFilepath = path.resolve(bundleDir || process.cwd(), reportFilename);

    mkdir.sync(path.dirname(reportFilepath));
    fs.writeFileSync(reportFilepath, reportHtml);

    logger.info(`${bold('Webpack Bundle Analyzer')} saved report to ${bold(reportFilepath)}`);

    if (openBrowser) {
      opener(`file://${reportFilepath}`);
    }
  });
}

function getAssetContent(filename) {
  return fs.readFileSync(`${projectRoot}/public/${filename}`, 'utf8');
}

function getChartData(analyzerOpts) {
  var chartData = void 0;
  var logger = analyzerOpts.logger;


  try {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    chartData = analyzer.getViewerData.apply(analyzer, args.concat([analyzerOpts]));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  } catch (err) {
    logger.error(`Could't analyze webpack bundle:\n${err}`);
    logger.debug(err.stack);
    chartData = null;
  }

  if (_.isPlainObject(chartData) && _.isEmpty(chartData)) {
    logger.error("Could't find any javascript bundles in provided stats file");
    chartData = null;
  }

  return chartData;
}