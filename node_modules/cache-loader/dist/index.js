<<<<<<< HEAD
"use strict";
=======
'use strict';
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

Object.defineProperty(exports, "__esModule", {
  value: true
});
<<<<<<< HEAD
exports.default = loader;
exports.pitch = pitch;
=======

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

/* eslint-disable
  import/order
*/
<<<<<<< HEAD
const fs = require('fs');

const path = require('path');

const normalizePath = require('normalize-path');

const async = require('neo-async');

const crypto = require('crypto');

const mkdirp = require('mkdirp');

const {
  getOptions
} = require('loader-utils');

const validateOptions = require('schema-utils');

const pkg = require('../package.json');

const env = process.env.NODE_ENV || 'development';

const schema = require('./options.json');

const defaults = {
  cacheContext: '',
=======
var fs = require('fs');
var path = require('path');
var async = require('neo-async');
var crypto = require('crypto');
var mkdirp = require('mkdirp');

var _require = require('loader-utils'),
    getOptions = _require.getOptions;

var validateOptions = require('schema-utils');

var pkg = require('../package.json');

var env = process.env.NODE_ENV || 'development';

var schema = require('./options.json');

var defaults = {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  cacheDirectory: path.resolve('.cache-loader'),
  cacheIdentifier: `cache-loader:${pkg.version} ${env}`,
  cacheKey,
  read,
  write
};

<<<<<<< HEAD
function pathWithCacheContext(cacheContext, originalPath) {
  if (!cacheContext) {
    return originalPath;
  }

  if (originalPath.includes(cacheContext)) {
    return originalPath.split('!').map(subPath => normalizePath(path.relative(cacheContext, subPath))).join('!');
  }

  return originalPath.split('!').map(subPath => normalizePath(path.resolve(cacheContext, subPath))).join('!');
}

function loader(...args) {
  const options = Object.assign({}, defaults, getOptions(this));
  validateOptions(schema, options, 'Cache Loader');
  const {
    write: writeFn
  } = options;
  const callback = this.async();
  const {
    data
  } = this;
  const dependencies = this.getDependencies().concat(this.loaders.map(l => l.path));
  const contextDependencies = this.getContextDependencies(); // Should the file get cached?

  let cache = true; // this.fs can be undefined
  // e.g when using the thread-loader
  // fallback to the fs module

  const FS = this.fs || fs;

  const toDepDetails = (dep, mapCallback) => {
    FS.stat(dep, (err, stats) => {
=======
function loader() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var options = Object.assign({}, defaults, getOptions(this));

  validateOptions(schema, options, 'Cache Loader');

  var writeFn = options.write;


  var callback = this.async();
  var data = this.data;

  var dependencies = this.getDependencies().concat(this.loaders.map(function (l) {
    return l.path;
  }));
  var contextDependencies = this.getContextDependencies();

  // Should the file get cached?
  var cache = true;

  var toDepDetails = function toDepDetails(dep, mapCallback) {
    fs.stat(dep, function (err, stats) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      if (err) {
        mapCallback(err);
        return;
      }

<<<<<<< HEAD
      const mtime = stats.mtime.getTime();
=======
      var mtime = stats.mtime.getTime();
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

      if (mtime / 1000 >= Math.floor(data.startTime / 1000)) {
        // Don't trust mtime.
        // File was changed while compiling
        // or it could be an inaccurate filesystem.
        cache = false;
      }

      mapCallback(null, {
<<<<<<< HEAD
        path: pathWithCacheContext(options.cacheContext, dep),
=======
        path: dep,
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        mtime
      });
    });
  };

<<<<<<< HEAD
  async.parallel([cb => async.mapLimit(dependencies, 20, toDepDetails, cb), cb => async.mapLimit(contextDependencies, 20, toDepDetails, cb)], (err, taskResults) => {
    if (err) {
      callback(null, ...args);
      return;
    }

    if (!cache) {
      callback(null, ...args);
      return;
    }

    const [deps, contextDeps] = taskResults;
=======
  async.parallel([function (cb) {
    return async.mapLimit(dependencies, 20, toDepDetails, cb);
  }, function (cb) {
    return async.mapLimit(contextDependencies, 20, toDepDetails, cb);
  }], function (err, taskResults) {
    if (err) {
      callback.apply(undefined, [null].concat(args));
      return;
    }
    if (!cache) {
      callback.apply(undefined, [null].concat(args));
      return;
    }

    var _taskResults = _slicedToArray(taskResults, 2),
        deps = _taskResults[0],
        contextDeps = _taskResults[1];

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    writeFn(data.cacheKey, {
      remainingRequest: data.remainingRequest,
      dependencies: deps,
      contextDependencies: contextDeps,
      result: args
<<<<<<< HEAD
    }, () => {
      // ignore errors here
      callback(null, ...args);
=======
    }, function () {
      // ignore errors here
      callback.apply(undefined, [null].concat(args));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    });
  });
}

function pitch(remainingRequest, prevRequest, dataInput) {
<<<<<<< HEAD
  const options = Object.assign({}, defaults, getOptions(this));
  validateOptions(schema, options, 'Cache Loader (Pitch)');
  const {
    read: readFn,
    cacheContext,
    cacheKey: cacheKeyFn
  } = options;
  const callback = this.async();
  const data = dataInput;
  data.remainingRequest = pathWithCacheContext(cacheContext, remainingRequest);
  data.cacheKey = cacheKeyFn(options, data.remainingRequest);
  readFn(data.cacheKey, (readErr, cacheData) => {
=======
  var _this = this;

  var options = Object.assign({}, defaults, getOptions(this));

  validateOptions(schema, options, 'Cache Loader (Pitch)');

  var readFn = options.read,
      cacheKeyFn = options.cacheKey;


  var callback = this.async();
  var data = dataInput;

  data.remainingRequest = remainingRequest;
  data.cacheKey = cacheKeyFn(options, remainingRequest);
  readFn(data.cacheKey, function (readErr, cacheData) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    if (readErr) {
      callback();
      return;
    }
<<<<<<< HEAD

    if (cacheData.remainingRequest !== data.remainingRequest) {
=======
    if (cacheData.remainingRequest !== remainingRequest) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      // in case of a hash conflict
      callback();
      return;
    }
<<<<<<< HEAD

    const FS = this.fs || fs;
    async.each(cacheData.dependencies.concat(cacheData.contextDependencies), (dep, eachCallback) => {
      FS.stat(dep.path, (statErr, stats) => {
=======
    async.each(cacheData.dependencies.concat(cacheData.contextDependencies), function (dep, eachCallback) {
      fs.stat(dep.path, function (statErr, stats) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        if (statErr) {
          eachCallback(statErr);
          return;
        }
<<<<<<< HEAD

=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
        if (stats.mtime.getTime() !== dep.mtime) {
          eachCallback(true);
          return;
        }
<<<<<<< HEAD

        eachCallback();
      });
    }, err => {
=======
        eachCallback();
      });
    }, function (err) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      if (err) {
        data.startTime = Date.now();
        callback();
        return;
      }
<<<<<<< HEAD

      cacheData.dependencies.forEach(dep => this.addDependency(pathWithCacheContext(cacheContext, dep.path)));
      cacheData.contextDependencies.forEach(dep => this.addContextDependency(pathWithCacheContext(cacheContext, dep.path)));
      callback(null, ...cacheData.result);
=======
      cacheData.dependencies.forEach(function (dep) {
        return _this.addDependency(dep.path);
      });
      cacheData.contextDependencies.forEach(function (dep) {
        return _this.addContextDependency(dep.path);
      });
      callback.apply(undefined, [null].concat(_toConsumableArray(cacheData.result)));
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    });
  });
}

function digest(str) {
  return crypto.createHash('md5').update(str).digest('hex');
}

<<<<<<< HEAD
const directories = new Set();

function write(key, data, callback) {
  const dirname = path.dirname(key);
  const content = JSON.stringify(data);
=======
var directories = new Set();

function write(key, data, callback) {
  var dirname = path.dirname(key);
  var content = JSON.stringify(data);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

  if (directories.has(dirname)) {
    // for performance skip creating directory
    fs.writeFile(key, content, 'utf-8', callback);
  } else {
<<<<<<< HEAD
    mkdirp(dirname, mkdirErr => {
=======
    mkdirp(dirname, function (mkdirErr) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      if (mkdirErr) {
        callback(mkdirErr);
        return;
      }

      directories.add(dirname);
<<<<<<< HEAD
=======

>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      fs.writeFile(key, content, 'utf-8', callback);
    });
  }
}

function read(key, callback) {
<<<<<<< HEAD
  fs.readFile(key, 'utf-8', (err, content) => {
=======
  fs.readFile(key, 'utf-8', function (err, content) {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    if (err) {
      callback(err);
      return;
    }

    try {
<<<<<<< HEAD
      const data = JSON.parse(content);
=======
      var data = JSON.parse(content);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
      callback(null, data);
    } catch (e) {
      callback(e);
    }
  });
}

function cacheKey(options, request) {
<<<<<<< HEAD
  const {
    cacheIdentifier,
    cacheDirectory
  } = options;
  const hash = digest(`${cacheIdentifier}\n${request}`);
  return path.join(cacheDirectory, `${hash}.json`);
}
=======
  var cacheIdentifier = options.cacheIdentifier,
      cacheDirectory = options.cacheDirectory;

  var hash = digest(`${cacheIdentifier}\n${request}`);

  return path.join(cacheDirectory, `${hash}.json`);
}

exports.default = loader;
exports.pitch = pitch;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
