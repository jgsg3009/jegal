"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverse;
Object.defineProperty(exports, "NodePath", {
  enumerable: true,
<<<<<<< HEAD
  get: function () {
=======
  get: function get() {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    return _path.default;
  }
});
Object.defineProperty(exports, "Scope", {
  enumerable: true,
<<<<<<< HEAD
  get: function () {
=======
  get: function get() {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    return _scope.default;
  }
});
Object.defineProperty(exports, "Hub", {
  enumerable: true,
<<<<<<< HEAD
  get: function () {
=======
  get: function get() {
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    return _hub.default;
  }
});
exports.visitors = void 0;

var _context = _interopRequireDefault(require("./context"));

var visitors = _interopRequireWildcard(require("./visitors"));

exports.visitors = visitors;

<<<<<<< HEAD
var _includes = _interopRequireDefault(require("lodash/includes"));

var t = _interopRequireWildcard(require("@babel/types"));
=======
function _includes() {
  const data = _interopRequireDefault(require("lodash/includes"));

  _includes = function _includes() {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function t() {
    return data;
  };

  return data;
}
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

var cache = _interopRequireWildcard(require("./cache"));

var _path = _interopRequireDefault(require("./path"));

var _scope = _interopRequireDefault(require("./scope"));

var _hub = _interopRequireDefault(require("./hub"));

<<<<<<< HEAD
function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
=======
function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function traverse(parent, opts, scope, state, parentPath) {
  if (!parent) return;
  if (!opts) opts = {};

  if (!opts.noScope && !scope) {
    if (parent.type !== "Program" && parent.type !== "File") {
      throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + `Instead of that you tried to traverse a ${parent.type} node without ` + "passing scope and parentPath.");
    }
  }

<<<<<<< HEAD
  if (!t.VISITOR_KEYS[parent.type]) {
    return;
  }

=======
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  visitors.explode(opts);
  traverse.node(parent, opts, scope, state, parentPath);
}

traverse.visitors = visitors;
traverse.verify = visitors.verify;
traverse.explode = visitors.explode;

traverse.cheap = function (node, enter) {
<<<<<<< HEAD
  return t.traverseFast(node, enter);
};

traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
  const keys = t.VISITOR_KEYS[node.type];
  if (!keys) return;
  const context = new _context.default(scope, opts, state, parentPath);

  for (const key of keys) {
=======
  return t().traverseFast(node, enter);
};

traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
  const keys = t().VISITOR_KEYS[node.type];
  if (!keys) return;
  const context = new _context.default(scope, opts, state, parentPath);

  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    const key = _ref;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
    if (skipKeys && skipKeys[key]) continue;
    if (context.visit(node, key)) return;
  }
};

traverse.clearNode = function (node, opts) {
<<<<<<< HEAD
  t.removeProperties(node, opts);
=======
  t().removeProperties(node, opts);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  cache.path.delete(node);
};

traverse.removeProperties = function (tree, opts) {
<<<<<<< HEAD
  t.traverseFast(tree, traverse.clearNode, opts);
=======
  t().traverseFast(tree, traverse.clearNode, opts);
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  return tree;
};

function hasBlacklistedType(path, state) {
  if (path.node.type === state.type) {
    state.has = true;
    path.stop();
  }
}

traverse.hasType = function (tree, type, blacklistTypes) {
<<<<<<< HEAD
  if ((0, _includes.default)(blacklistTypes, tree.type)) return false;
=======
  if ((0, _includes().default)(blacklistTypes, tree.type)) return false;
>>>>>>> 99ef3b4711c8dcd2f717e43dd012712d1f333361
  if (tree.type === type) return true;
  const state = {
    has: false,
    type: type
  };
  traverse(tree, {
    noScope: true,
    blacklist: blacklistTypes,
    enter: hasBlacklistedType
  }, null, state);
  return state.has;
};

traverse.cache = cache;